
PROC controlSystem ( CHAN OF ANY out, back, fb.in, CHAN OF INT image.selection, VAL INT machines )

  #INCLUDE "PROTOCOL.INC"

  PROC writes ( VAL [] BYTE s, [256] INT buffer )
    SEQ
      SEQ i = 0 FOR SIZE s
        buffer [i] := INT s [i]
      fb.in ! c.message; SIZE s; [ buffer FROM 0 FOR SIZE s ]
  :

  #INCLUDE "WORLD.INC"

  PROC sendPatches ( CHAN OF ANY out, VAL INT patchEdge, [256] INT buffer )
    VAL patchesWide IS 256 / patchEdge :
    SEQ
      SEQ x = 0 FOR patchesWide
        SEQ y = 0 FOR patchesWide
          out ! c.render; (x * patchEdge) + 128; (y * patchEdge) + 128
      out ! c.stop
  :

  PROC loadBalance ( CHAN OF ANY in, out, return, fb.in,
                     VAL INT machines,
                     [256] INT buffer )
    BOOL passActive, farmActive :
    INT free, command :
    SEQ
      farmActive := TRUE
      passActive := TRUE
      free := machines * 2
      WHILE passActive OR farmActive
        PRI ALT
          (free > 0) & in ? command
            IF
              command = c.render
                INT x, y :
                SEQ
                  --writes ( "*N*C S c.render to system", buffer)
                  in  ? x; y
                  out ! command; x; y
                  free := free - 1
              command = c.stop
                SEQ
                  writes ( "*N*C R c.stop from pumper", buffer)
                  out ! c.stop
                  passActive := FALSE
          return ? command
            IF
              command = c.patch
                INT x, y, size :
                SEQ
                  --writes ( "*N*C R patch", buffer)
                  return   ? x; y; size
                  fb.in ! command; x; y; size
                  SEQ i = 0 FOR size
                    SEQ
                      return   ? [ buffer FROM 0 FOR size ]
                      fb.in ! [ buffer FROM 0 FOR size ]
                  free := free + 1
              command = c.message
                INT size :
                SEQ
                  return   ? size; [ buffer FROM 0 FOR size ]
                  fb.in ! command; size; [ buffer FROM 0 FOR size ]
              command = c.stop
                SEQ
                  farmActive := FALSE
                  writes ( "*N*C received c.stop", buffer)
      fb.in ! c.stop
  :

  PROC outputBuffer ( CHAN OF ANY in, out )
    INT command :
    SEQ
      in ? command
      WHILE command <> c.stop
        SEQ
          IF
            command = c.render
              INT x, y :
              SEQ
                in  ? x; y
                out ! command; x; y
          in ? command
      out ! command
  :

  PROC returnBuffer ( CHAN OF ANY in, out, [256] INT buffer )
    INT command :
    SEQ
      in ? command
      WHILE command <> c.stop
        SEQ
          IF
            command = c.patch
              INT x, y, size :
              SEQ
                in  ? x; y; size
                out ! command; x; y; size
                SEQ i = 0 FOR size
                  SEQ
                    in  ? [ buffer FROM 0 FOR size ]
                    out ! [ buffer FROM 0 FOR size ]
            command = c.message
              INT size :
              SEQ
                in ? size; [ buffer FROM 0 FOR size ]
                out ! command; size; [ buffer FROM 0 FOR size ]
          in ? command
      out ! command
  :

  -- PROC controlSystem ( CHAN OF ANY out, back, fb.in, CHAN OF INT image.selection, VAL INT machines )
  VAL patchEdge IS 3 :
  [4][256] INT buffer :
  CHAN OF ANY a, b, c :
  WHILE TRUE
    SEQ
      pumpWorldModels ( out, image.selection, patchEdge, buffer [0] )
      PAR
        sendPatches  ( a, patchEdge, buffer[3])
        outputBuffer ( b, out  )
        returnBuffer ( back, c, buffer [1] )
        loadBalance  ( a, b, c, fb.in, machines, buffer [2] )
:

