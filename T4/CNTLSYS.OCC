-- out, back is link to first worker
-- graphics is output to framebuf
-- machines is total number of workers

-- upstream commands:
--    c.render
--    c.stop
-- downstream command:
--    c.patch
--    c.done
--    c.stop

-- out is to workers
-- back is from workers
-- graphics is to renderer
PROC controlSystem ( CHAN OF ANY out, back, graphics, VAL INT machines )


  VAL c.render      IS 1 :  -- x0; y0
  VAL c.tick        IS 8 :  -- worker;debug;

  PROC ledon(VAL INT delay)
    TIMER t :
    INT start :
    SEQ
      ASM
        CLRHALTERR
        SETERR
      t ? start
      t ? AFTER start PLUS (delay)
  :
  
  PROC ledoff()
    ASM
      TESTERR
  :

  -- flood out channel with the patch render commands for each 8*8 block (patchEdge=8)
  PROC sendPatches ( CHAN OF ANY out, VAL INT patchEdge)
    VAL patchesWide IS 256 / patchEdge :
    SEQ
      SEQ x = 0 FOR patchesWide
        SEQ y = 0 FOR patchesWide
          SEQ
            out ! c.render
  :

  -- feed work into the pipeline so long as there are free workers
  -- original code had machines*2 since each worker could either be rendering, or buffer one lot of parameters
  -- c.stop traverses the pipeline and is reflected back so when it comes back here we know the pipeline has stopped

  -- in receives patch commands from sendPatches()
  -- out is to workers - via outputBuffer()
  -- return from workers - via returnBuffer()
  -- graphics is to renderer
  PROC loadBalance ( CHAN OF ANY in, out, return, graphics,
                     VAL INT machines)
    INT free, command :
    SEQ
      free := machines 
      WHILE TRUE
        SEQ
          graphics ! c.tick; 258; free
          in ? command
          SEQ
            IF
              command = c.render
                SEQ
                  graphics ! c.tick; 260; free
                  ledon(1000)
                  out ! command
                  graphics ! c.tick; 261; free
                  ledoff()
                  free := free - 1
  :

  VAL patchEdge IS 8 :
  CHAN OF ANY a :
  WHILE TRUE
    PAR
      sendPatches  ( a, patchEdge)
      loadBalance  ( a, out, back, graphics, machines )
:

