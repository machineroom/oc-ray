#INCLUDE "hostio.inc"
#INCLUDE "streamio.inc"

#USE "hostio.lib"
#USE "streamio.lib"

PROC frameBuffer (CHAN OF SP fs, ts, CHAN OF ANY in, CHAN OF INT image, 
                  VAL INT processors,
                  VAL INT frameRate, lineFreq, interLace, pixelClock )

  [512][512] BYTE screenRAM :  -- buffered 512 x 512 x 8-bit pixels
  
  PROC displayPatch ( VAL INT x, y, size, [16][16] INT patch )
    VAL y.y IS (y + y) - 256 :
    VAL x.x IS (x + x) - 256 :
    INT ptr, flip :
    BOOL display :
    SEQ
      ptr := ((511 - y.y) << 9) + x.x

      [512*512] BYTE iscreen RETYPES screenRAM :
      SEQ j = 0 FOR size
        pLine IS patch [j] :
        INT lptr :
        SEQ
          lptr := ptr
          SEQ i = 0 FOR size    -- inner loop in x
            VAL colour IS pLine [i] :
            INT r, g, b :
            SEQ
              -- word is xxbbbbbbbbbbggggggggggrrrrrrrrrr
              r := (colour >>  2) /\ #FF -- bottom 8 bits
              g := (colour >> 12) /\ #FF
              b := (colour >> 22) /\ #FF

              iscreen [     lptr] := BYTE r
              iscreen [   lptr+1] := BYTE g
              iscreen [ lptr-512] := BYTE b
              iscreen [ lptr-511] := BYTE 0

              lptr := lptr + 2
          ptr := ptr - 1024
  :


    ---------------------------- COMMANDS PROTOCOL -----------------------------
  
  VAL c.stop    IS 0 :
  VAL c.render  IS 1 :  -- render; x0; y0
  VAL c.object  IS 2 :  -- object; size; [ size ]
  VAL c.light   IS 3 :  -- light;  size; [ size ]
  VAL c.patch   IS 4 :  -- patch;  x; y; patchSize; [ patchSize][patchSize]
  VAL c.runData IS 5 :  -- ambient light, rendering mode, screen pos etc.
  VAL c.message IS 6 :  -- message; size; [ words ]


  VAL patchSize IS 16 :

  PROC MenuSelection (CHAN OF INT image)
    BYTE InKey, Result :
    BOOL Selected :

    SEQ
      Selected := FALSE
      so.write.string.nl(fs,ts,"                                                           ")
      so.write.string.nl(fs,ts,"               RayTracer Image Selection                   ")
      so.write.string.nl(fs,ts,"               =========================                   ")
      so.write.string.nl(fs,ts,"                                                           ")
      so.write.string.nl(fs,ts,"               <5>  (small) Cylinder, Sphere Image         ")
      so.write.string.nl(fs,ts,"                                                           ")
      so.write.string   (fs,ts," Your Selection ")                      

      WHILE NOT (Selected)
        SEQ
          so.getkey(fs,ts,InKey,Result)
          IF
            (Result = spr.ok)
              SEQ
                IF
                  ((InKey >= '1') AND (InKey <= '5'))
                    SEQ
                      image ! (INT InKey) - (INT '0')
                      so.write.int(fs, ts, (INT InKey) - (INT '0'), 1)
                      so.write.nl (fs, ts)
                      Selected := TRUE
                  TRUE
                    SKIP
            TRUE
              SKIP
  :
                       

  ---------------------------- COMMANDS PROTOCOL -----------------------------

  VAL ticksPerSecond IS 625000 / 64 :  -- lo priority

  CHAN OF ANY fromRenderer :
  PRI PAR
    WHILE TRUE
      INT command :
      SEQ
        in ? command
        IF
          command = c.patch
            INT x, y, size :
            [16][16] INT patch :
            SEQ
              in ? x; y; size
              SEQ i = 0 FOR size
                in ? [ patch [i] FROM 0 FOR size ]
              fromRenderer ! command; x; y; size
              SEQ i = 0 FOR size
                fromRenderer ! [ patch [i] FROM 0 FOR size ]
          command = c.message
            INT size :
            [256] INT chars :
            SEQ
              in ? size; [ chars FROM 0 FOR size ]
              fromRenderer ! command; size; [ chars FROM 0 FOR size ]
          command = c.stop
            fromRenderer ! command
    SEQ
      ---------------------------- MAX COLOUR ------------------------------
      [512] BYTE line :
      SEQ
        SEQ i = 0 FOR 256
          line [i] := BYTE i
        [ line FROM 256 FOR 256 ] := [ line FROM 0 FOR 256 ]
        SEQ y = 0 FOR 512
          screenRAM [y] := line

      ---------------------------- DO THE ACTION ---------------------------

      TIMER clock :
      INT start, end :

      REAL32 realTime, realTicks :

      VAL uSecsPerTick IS 64 :
      VAL iticks       IS 1000000 / 64 :
      VAL ticks IS REAL32 TRUNC iticks :
      INT command :
      SEQ
        MenuSelection(image)
        so.write.string.nl (fs, ts, " The inmos ray tracer is GO")
        clock ? start
        fromRenderer ? command
        WHILE command <> c.stop
          SEQ
            IF
              command = c.patch
                INT x, y, size :
                [16][16] INT patch :
                SEQ
                  fromRenderer ? x; y; size
                  so.write.string (fs, ts, "FB patch x=")
                  so.write.int (fs, ts, x, 1)
                  so.write.string (fs, ts, ",y=")
                  so.write.int (fs, ts, y, 1)
                  so.write.string (fs, ts, ",size=")
                  so.write.int (fs, ts, size, 1)
                  so.write.string.nl (fs, ts, "")
                  SEQ i = 0 FOR size
                    fromRenderer ? [ patch [i] FROM 0 FOR size ]
                  displayPatch ( x, y, size, patch )
              command = c.message
                INT size :
                [256] INT chars :
                [256] BYTE OutString : 
                SEQ
                  fromRenderer ? size; [ chars FROM 0 FOR size ]
                  --so.write.string (fs, ts, "FB cmd fsize ")
                  --so.write.int (fs, ts, size, 1)
                  --so.write.string.nl (fs, ts, "")
                  SEQ i = 0 FOR size   
                    OutString[i] := BYTE (chars[i] /\ #FF)
                  so.write.string.nl (fs, ts, [OutString FROM 0 FOR size])
              TRUE
                SEQ
                  so.write.string.nl (fs, ts,"FB GARBAGE COMMAND")
                  STOP
            --so.write.string.nl (fs, ts, "FB await command")
            fromRenderer ? command
        clock ? end
        SEQ
          realTicks := REAL32 TRUNC (end MINUS start)
          realTime  := realTicks / ticks
          so.write.nl (fs, ts)
          so.write.string (fs, ts, " DONE, took ")
          so.write.real32 (fs,ts, realTime, 5, 2)
          so.write.string (fs,ts, " seconds on ")
          so.write.int (fs,ts, processors, 2)
          so.write.string.nl (fs, ts, " processors.")
        clock ? start
        clock ? AFTER (start PLUS (20 * iticks))

      INT32 Status :
      SEQ
        so.exit (fs, ts, Status)      
:

