PROC rayTrace   ( CHAN OF ANY fromPrev, toPrev, fromNext, toNext,
                    VAL INT propogate, me )

  #USE "occama.lib"     --T414 math library
  --#USE "occam8.lib"     --T8xx math library

  VAL patchSize IS 16 :
  VAL c.stop    IS 0 :
  VAL c.render  IS 1 :  -- render; x0; y0
  VAL c.object  IS 2 :  -- object; size; [ size ]
  VAL c.light   IS 3 :  -- light;  size; [ size ]
  VAL c.patch   IS 4 :  -- patch;  x; y; patchSize; [ patchSize][patchSize]
  VAL c.runData IS 5 :  -- ambient light, rendering mode, screen pos etc.
  VAL c.message IS 6 :  -- message; size; [ words ]

  VAL nil       IS -1 :

  -- the attribute word contains gross attributes of the object as
  -- bits. The relevant words in the object descriptor expand upon these

  VAL sizeWorld IS 1800 :  -- a sphere = 17 words + nextPtr,
                           -- giving 100 spheres

  VAL l.dx   IS 3 :   -- light direction cosines x y z
  
  VAL l.size IS 6 :

  -- each light is |nextPtr|r|g|b|dx|dy|dz

  VAL sizeLight  IS  7 :

  VAL maxLights  IS 10 :   -- any more than 2 is hell to shade !!

  VAL sizeLights IS sizeLight * maxLights :

  PROC throughPut ( [256] INT work,
                    CHAN OF ANY fromPrev, toNext, feedPixels, pixelTrigger,
                    VAL INT propogate )

    VAL closeDown     IS 0 :
    VAL active        IS 1 :
    VAL busy          IS 2 :
    VAL buffered      IS 4 :

    INT state, tag :
    INT x, y, size, kick :
    SEQ
      state := active
      WHILE state <> closeDown
        PRI ALT
          pixelTrigger ? kick  -- should be guarded by (state /\ busy) <> 0 ..
            IF
              (state /\ buffered) <> 0
                SEQ
                  feedPixels ! c.render; x; y
                  state := active \/ busy
              TRUE
                state := active -- i.e not busy and not buffered
          fromPrev ? tag
            IF
              tag = c.render
                INT a, b :
                SEQ
                  fromPrev ? a; b
                  IF
                    (state /\ busy) = 0
                      SEQ
                        feedPixels ! tag; a; b
                        state := active \/ busy

                    (state /\ buffered) <> 0
                      toNext ! tag; a; b
                    TRUE
                      SEQ
                        x     := a
                        y     := b
                        state := active \/ (busy \/ buffered)
              tag = c.stop
                SEQ
                  IF
                    (state /\ busy) <> 0
                      pixelTrigger ? kick
                    TRUE
                      SKIP
                  IF
                    (state /\ buffered) <> 0
                      SEQ
                        feedPixels   ! c.render; x; y
                        pixelTrigger ? kick
                    TRUE
                      SKIP
                  feedPixels ! tag
                  toNext     ! tag
                  state := closeDown
              TRUE
                SEQ
                  fromPrev ? size; [ work FROM 0 FOR size ]
                  IF
                    propogate <> 0
                      toNext ! tag; size; [ work FROM 0 FOR size ]
                    TRUE
                      SKIP
                  feedPixels ! tag; size; [ work FROM 0 FOR size ]
  :



  PROC pixelBypass ( [3][256] INT buffers,
                     CHAN OF ANY toPrev, fromNext, fromThis)
    PROC buffer ( [256] INT pixels, CHAN OF ANY in, out )
      INT command :
      SEQ
        in ? command
        WHILE command <> c.stop
          INT x, y, size :
          SEQ
            IF
              command = c.patch
                SEQ
                  in  ? x; y; size
                  out ! command; x; y; size
                  SEQ i = 0 FOR size
                    SEQ
                      in  ? [ pixels FROM 0 FOR size ]
                      out ! [ pixels FROM 0 FOR size ]
              command = c.message
                SEQ
                  in  ? size; [ pixels FROM 0 FOR size ]
                  out ! command; size; [ pixels FROM 0 FOR size ]
            in ? command
        out ! c.stop
    :


    PROC mix ( [256] INT pixels, CHAN OF ANY fromOther, fromThis, out)
      INT  state, command, x, y, size :

      VAL closeDown  IS 0 :
      VAL lubThis    IS 1 :
      VAL lubOther   IS 2 :

      PROC pass ( CHAN OF ANY in, out )
        buffer IS pixels : -- save static chaining
        SEQ i = 0 FOR size
          SEQ
            in  ? [ buffer FROM 0 FOR size ]
            out ! [ buffer FROM 0 FOR size ]
      :
      SEQ
        state := lubThis \/ lubOther
        WHILE state <> closeDown
          PRI ALT
            fromOther ? command
              SEQ
                IF
                  command = c.message
                    SEQ
                      fromOther ? size; [ pixels FROM 0 FOR size ]
                      out ! command; size; [ pixels FROM 0 FOR size ]
                  command = c.patch
                    SEQ
                      fromOther ? x; y; size
                      out ! command; x; y; size
                      pass ( fromOther, out )
                  command = c.stop
                    state := state >< lubOther
            fromThis ? command
              SEQ
                IF
                  command = c.message
                    SEQ
                      fromThis ? size; [ pixels FROM 0 FOR size ]
                      out ! command; size; [ pixels FROM 0 FOR size ]
                  command = c.patch
                    SEQ
                      fromThis ? x; y; size
                      out ! command; x; y; size
                      pass ( fromThis, out )
                  command = c.stop
                    state := state >< lubThis
        out ! c.stop
    :

    CHAN OF ANY lubThis, lubOther :
    PAR
      buffer ( buffers [0], fromNext, lubOther)
      buffer ( buffers [1], fromThis, lubThis)
      mix    ( buffers [2], lubOther, lubThis, toPrev)
  :


  
  [20] INT grunData :


  [sizeWorld] INT    gworldModel :

  [sizeLights] INT glights :
  [patchSize][patchSize] INT gcolours : -- these are the AREA-AVERAGED colours
                                        -- returned to the grafix cards,
                                        -- not the point samples



  PROC renderer ( CHAN OF ANY workIn, pixelsOut, done )
    [20] INT runData IS grunData :

    runPatchSize  IS runData [4] :

    [sizeWorld] INT worldModel IS gworldModel :

    INT world.p :  -- pointer used during construction of model
    [sizeLights] INT lights IS glights :
    [sizeLights] REAL32 flights RETYPES lights :

    INT light.p :  -- pointer used during construction of model

    [patchSize][patchSize] INT colours IS gcolours :

    [256] INT message :
    INT mess.p :

    PROC wrch ( VAL INT ch )
      IF
        ch = (-7)
          SEQ
            pixelsOut ! c.message; mess.p; [ message FROM 0 FOR mess.p ]
            mess.p := 0
        mess.p = 256
          SKIP
        TRUE
          SEQ
            message [ mess.p] := ch
            mess.p := mess.p + 1
    :


    PROC writen ( VAL INT num)
      [20] INT stack :
      INT sp :
      PROC push (VAL INT push)
        SEQ
          stack[sp] := push
          sp := sp + 1
          SKIP
      :

      PROC pop (INT pop)
        SEQ
          sp := sp - 1
          pop := stack[sp]
          SKIP
      :

      VAL nil IS #DEAD :
      INT n :
      SEQ
        IF
          num < 0
            SEQ
              n := -num
              wrch ( INT '-')
          TRUE
            n := num
        sp := 0
        push (nil)
        WHILE n > 9
          SEQ
            push (n \ 10)
            n := n / 10
        WHILE n <> nil
          SEQ
            wrch ( n + (INT '0'))
            pop (n)
    :

    PROC writef ( VAL [] BYTE str, VAL INT a, b, c, d)
      INT chptr, ch, ptr :
      [4] INT args :
      SEQ
        ptr     := 0
        chptr   := 0
        args[0] := a
        args[1] := b
        args[2] := c
        args[3] := d
        WHILE chptr < (SIZE str)
          SEQ
            ch := INT str[chptr]
            IF
              ch = (INT '%')
                SEQ
                  chptr := chptr + 1
                  ch := INT str [chptr]
                  IF
                    (ch = (INT 'I')) OR (ch = (INT 'i'))
                      SEQ
                        writen ( args[ptr])
                        IF
                          ptr = 3
                            SKIP
                          TRUE
                            ptr := ptr + 1
                    TRUE
                      SKIP

              TRUE
                wrch ( ch)
            chptr := chptr + 1
        wrch ( -7)
    :


    VAL ticksPerSecond IS 625000 / 64 :  -- lo priority
    INT command :
    INT nrays, nobj, nlight, secs, ticks, then :
    TIMER TIME :
    SEQ
      secs    := 0
      ticks   := 0
      TIME ? then
      nrays   := 0
      nobj    := 0
      nlight  := 0
      command := 0         -- clear command for when i move to bytes
      world.p := 0         -- empty world model
      light.p := 0         -- and lights list
      mess.p  := 0         -- clear debug message
      workIn ? command     -- (eventually) pull in 1 byte
      WHILE command <> c.stop
        SEQ
          IF
            command = c.render
              INT x0, y0 :
              SEQ
                workIn ? x0; y0
                writef ( "Worker %I done on %I %I", me, x0, y0, 0 )
                pixelsOut ! c.patch; x0; y0; runPatchSize
                SEQ y = 0 FOR runPatchSize
                  pixelsOut ! [ colours [y] FROM 0 FOR runPatchSize ]
                done ! 42
            command = c.object
              SEQ
                nobj := nobj + 1
                workIn ? worldModel [ world.p];
                       [ worldModel FROM world.p + 1 FOR worldModel [ world.p]]
                world.p := world.p + (worldModel [ world.p] + 1)
            command = c.light
              REAL32 hyp :
              SEQ
                nlight := nlight + 1
                workIn ? lights [ light.p] ;
                       [ lights FROM light.p + 1 FOR lights [ light.p]]
            command = c.runData
              INT size :
              SEQ
                workIn ? size; [ runData FROM 0 FOR size ]
                lights     [ light.p] := nil
                worldModel [ world.p] := nil
            TRUE
              SEQ
                writef ( "Worker %I received garbage command %I", me, command, 0,0)
                STOP
          INT now, delay :
          SEQ
            TIME ? now
            delay := now MINUS then
            IF
              delay > ticksPerSecond
                SEQ
                  secs  := secs + (delay / ticksPerSecond)
                  ticks := delay \ ticksPerSecond
                  then  := now PLUS ticks
              TRUE
                SKIP
          workIn ? command
      writef ( "Worker %I DONE in %I seconds, scene of %I objects",
        me, secs, nobj, 0 )
      writef ( "Worker %I, %I lights traced %I rays", me, nlight, nrays, 0 )
      pixelsOut ! command
  :

  CHAN OF ANY feedPixels, pixelTrigger, pixelsOut :

  [4][256] INT buffers :

  WHILE TRUE
    PRI PAR
      PAR
        throughPut  ( buffers [0],
                      fromPrev, toNext, feedPixels, pixelTrigger,
                      propogate )
        pixelBypass ( [ buffers FROM 0 FOR 3], toPrev, fromNext,  pixelsOut )
      renderer   ( feedPixels, pixelsOut, pixelTrigger )
:


