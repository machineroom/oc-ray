PROC rayTrace   ( CHAN OF ANY fromPrev, toPrev, fromNext, toNext,
                    VAL INT propogate, me )

  #USE "occama.lib"     --T414 math library
  --#USE "occam8.lib"     --T8xx math library

  VAL c.stop    IS 0 :
  VAL c.render  IS 1 :  -- render; x0; y0
  VAL c.object  IS 2 :  -- object; size; [ size ]
  VAL c.light   IS 3 :  -- light;  size; [ size ]
  VAL c.patch   IS 4 :  -- patch;  x; y; patchSize; [ patchSize][patchSize]
  VAL c.runData IS 5 :  -- ambient light, rendering mode, screen pos etc.
  VAL c.message IS 6 :  -- message; size; [ words ]

  VAL m.adaptive   IS 0 :
  VAL m.stochastic IS 1 :
  VAL m.dumb       IS 2 :
  VAL m.test       IS 3 :

  VAL nil       IS -1 :

  VAL n.reflect IS 0 :        -- point to children
  VAL n.refract IS 1 :
  VAL n.next    IS 2 :        -- maintain linked list of leaf nodes
  VAL n.type    IS 3 :        -- reflected, refracted or primary ray

  -- Valid ray types for n.type slot

  VAL rt.root IS 0 :   -- only first ray is of this type
  VAL rt.spec IS 1 :   -- reflected ray
  VAL rt.frac IS 2 :   -- transmitted ray

  VAL n.objptr  IS 4 :        -- pointer into world model for intersect

  VAL n.sectx   IS 5 :        -- point of intersection
  VAL n.secty   IS 6 :
  VAL n.sectz   IS 7 :

  VAL n.normx   IS 8 :        -- surface normal at point of intersection
  VAL n.normy   IS 9 :
  VAL n.normz   IS 10 :

  VAL n.t       IS 11 :       -- distance parameter 't' of intersection

  VAL n.startx  IS 12 :       -- ray origin
  VAL n.starty  IS 13 :
  VAL n.startz  IS 14 :

  VAL n.dx      IS 15 :       -- ray direction
  VAL n.dy      IS 16 :
  VAL n.dz      IS 17 :

  VAL n.red   IS 18 :
  VAL n.green IS 19 :
  VAL n.blue  IS 20 :

  VAL nodeSize IS n.blue + 1 :

  VAL maxDepth IS 6 :
  VAL maxNodes IS 4 + (2 << maxDepth) :  -- traverse tree 5 deep max,
                                         -- PLUS 4 for good measure
  VAL treeSize  IS nodeSize * maxNodes : -- shadow generation

  VAL o.sphere    IS 0 :
  VAL o.xyplane   IS 1 :
  VAL o.xzplane   IS 2 :
  VAL o.yzplane   IS 3 :
  VAL o.plane     IS 4 :
  VAL o.cone      IS 5 :
  VAL o.cylinder  IS 6 :
  VAL o.ellipsoid IS 7 :
  VAL o.quadric   IS 8 : -- general quadric, hell to compute

  VAL x.axis     IS  0 :
  VAL y.axis     IS  1 :
  VAL z.axis     IS  2 :

  -- the attribute word contains gross attributes of the object as
  -- bits. The relevant words in the object descriptor expand upon these

  VAL a.spec     IS #01 :  -- use lambert / use phong and reflect
  VAL a.frac     IS #02 :  -- refract on surface
  VAL a.bound0   IS #04 :  -- bounded in 1 dimension
  VAL a.bound1   IS #08 :  -- bounded in 2 dimension
  VAL a.tex      IS #10 :  -- texture map ?
  VAL a.bump     IS #20 :  -- bump map    ?

  VAL o.type     IS  0 : -- type field of all objects
  VAL o.attr     IS  1 : -- attribute field of all object

  VAL o.kdR      IS  2 :  -- coeffs of diffuse reflection R G B
  VAL o.kdG      IS  3 :
  VAL o.kdB      IS  4 :

  VAL o.ks       IS  5 :  -- coeff of specular reflection ( for reflections)

  VAL o.kg       IS  6 :  -- coeff of gloss for phong shading
  VAL o.xmitR    IS  7 :  -- coeffs of transmission R G B
  VAL o.xmitG    IS  8 :
  VAL o.xmitB    IS  9 :

  VAL o.power    IS 10 :  -- power for phong shading
  VAL o.refix    IS 11 :  -- refractive index (relative)

  VAL o.specific IS 12 :

  VAL first      IS o.specific :

  VAL s.rad      IS  first + 0 :
  VAL s.x        IS  first + 1 :
  VAL s.y        IS  first + 2 :
  VAL s.z        IS  first + 3 :

  VAL s.map      IS  first + 4 :  -- which map ( texture or bump)
  VAL s.uoffs    IS  first + 5 :  -- offsets for u and v in map
  VAL s.voffs    IS  first + 6 :
  VAL s.size     IS  first + 7 :
  VAL sizeWorld IS 1800 :  -- a sphere = 17 words + nextPtr,
                           -- giving 100 spheres

  VAL l.ir   IS 0 :   -- light intensity fields  R G B
  VAL l.ig   IS 1 :
  VAL l.ib   IS 2 :

  VAL l.dx   IS 3 :   -- light direction cosines x y z
  VAL l.dy   IS 4 :   -- this is a quick'n'tacky shading sheme
  VAL l.dz   IS 5 :

  VAL l.size IS 6 :

  -- each light is |nextPtr|r|g|b|dx|dy|dz

  VAL sizeLight  IS  7 :

  VAL maxLights  IS 10 :   -- any more than 2 is hell to shade !!

  VAL sizeLights IS sizeLight * maxLights :

  VAL maxDescend   IS 2 :    -- this is a space limitation on the sub-pixel
                             -- grid rather than a compute saver
  VAL descendPower IS 4 :    -- 2 ^^ maxDescend

  VAL patchSize IS 16 :
  VAL gridSize  IS ((patchSize + 1) * descendPower) + 1 :

  VAL mint  IS MOSTNEG INT :

  -- colours are nr | 10 blue bits | 10 green bits | 10 red bits |

  VAL threshold   IS 10 << 2 : -- this is 10 on a scale of 256, but we
  VAL colourBits  IS 10 :      -- generate 10 bits

  VAL rMask       IS (1 << colourBits) - 1 :
  VAL gMask       IS rMask    << colourBits :
  VAL bMask       IS gMask    << colourBits :

  VAL rMaxDiff    IS threshold :               -- threshold values for
  VAL gMaxDiff    IS rMaxDiff << colourBits :  -- instancing super sample
  VAL bMaxDiff    IS gMaxDiff << colourBits :

  VAL notRendered IS mint :  -- top bit set = not rendered



  PROC throughPut ( [256] INT work,
                    CHAN OF ANY fromPrev, toNext, feedPixels, pixelTrigger,
                    VAL INT propogate )

    VAL closeDown     IS 0 :
    VAL active        IS 1 :
    VAL busy          IS 2 :
    VAL buffered      IS 4 :

    INT state, tag :
    INT x, y, size, kick :
    SEQ
      state := active
      WHILE state <> closeDown
        PRI ALT
          pixelTrigger ? kick  -- should be guarded by (state /\ busy) <> 0 ..
            IF
              (state /\ buffered) <> 0
                SEQ
                  feedPixels ! c.render; x; y
                  state := active \/ busy
              TRUE
                state := active -- i.e not busy and not buffered
          fromPrev ? tag
            IF
              tag = c.render
                INT a, b :
                SEQ
                  fromPrev ? a; b
                  IF
                    (state /\ busy) = 0
                      SEQ
                        feedPixels ! tag; a; b
                        state := active \/ busy

                    (state /\ buffered) <> 0
                      toNext ! tag; a; b
                    TRUE
                      SEQ
                        x     := a
                        y     := b
                        state := active \/ (busy \/ buffered)
              tag = c.stop
                SEQ
                  IF
                    (state /\ busy) <> 0
                      pixelTrigger ? kick
                    TRUE
                      SKIP
                  IF
                    (state /\ buffered) <> 0
                      SEQ
                        feedPixels   ! c.render; x; y
                        pixelTrigger ? kick
                    TRUE
                      SKIP
                  feedPixels ! tag
                  toNext     ! tag
                  state := closeDown
              TRUE
                SEQ
                  fromPrev ? size; [ work FROM 0 FOR size ]
                  IF
                    propogate <> 0
                      toNext ! tag; size; [ work FROM 0 FOR size ]
                    TRUE
                      SKIP
                  feedPixels ! tag; size; [ work FROM 0 FOR size ]
  :



  PROC pixelBypass ( [3][256] INT buffers,
                     CHAN OF ANY toPrev, fromNext, fromThis)
    PROC buffer ( [256] INT pixels, CHAN OF ANY in, out )
      INT command :
      SEQ
        in ? command
        WHILE command <> c.stop
          INT x, y, size :
          SEQ
            IF
              command = c.patch
                SEQ
                  in  ? x; y; size
                  out ! command; x; y; size
                  SEQ i = 0 FOR size
                    SEQ
                      in  ? [ pixels FROM 0 FOR size ]
                      out ! [ pixels FROM 0 FOR size ]
              command = c.message
                SEQ
                  in  ? size; [ pixels FROM 0 FOR size ]
                  out ! command; size; [ pixels FROM 0 FOR size ]
            in ? command
        out ! c.stop
    :


    PROC mix ( [256] INT pixels, CHAN OF ANY fromOther, fromThis, out)
      INT  state, command, x, y, size :

      VAL closeDown  IS 0 :
      VAL lubThis    IS 1 :
      VAL lubOther   IS 2 :

      PROC pass ( CHAN OF ANY in, out )
        buffer IS pixels : -- save static chaining
        SEQ i = 0 FOR size
          SEQ
            in  ? [ buffer FROM 0 FOR size ]
            out ! [ buffer FROM 0 FOR size ]
      :
      SEQ
        state := lubThis \/ lubOther
        WHILE state <> closeDown
          PRI ALT
            fromOther ? command
              SEQ
                IF
                  command = c.message
                    SEQ
                      fromOther ? size; [ pixels FROM 0 FOR size ]
                      out ! command; size; [ pixels FROM 0 FOR size ]
                  command = c.patch
                    SEQ
                      fromOther ? x; y; size
                      out ! command; x; y; size
                      pass ( fromOther, out )
                  command = c.stop
                    state := state >< lubOther
            fromThis ? command
              SEQ
                IF
                  command = c.message
                    SEQ
                      fromThis ? size; [ pixels FROM 0 FOR size ]
                      out ! command; size; [ pixels FROM 0 FOR size ]
                  command = c.patch
                    SEQ
                      fromThis ? x; y; size
                      out ! command; x; y; size
                      pass ( fromThis, out )
                  command = c.stop
                    state := state >< lubThis
        out ! c.stop
    :

    CHAN OF ANY lubThis, lubOther :
    PAR
      buffer ( buffers [0], fromNext, lubOther)
      buffer ( buffers [1], fromThis, lubThis)
      mix    ( buffers [2], lubOther, lubThis, toPrev)
  :


  
  [20] INT grunData :


  [sizeWorld] INT    gworldModel :

  [sizeLights] INT glights :
  [patchSize][patchSize] INT gcolours : -- these are the AREA-AVERAGED colours
                                        -- returned to the grafix cards,
                                        -- not the point samples



  PROC renderer ( CHAN OF ANY workIn, pixelsOut, done )
    [20] INT runData IS grunData :

    runPatchSize  IS runData [4] :

    [sizeWorld] INT worldModel IS gworldModel :

    INT world.p :  -- pointer used during construction of model
    [sizeLights] INT lights IS glights :
    [sizeLights] REAL32 flights RETYPES lights :

    INT light.p :  -- pointer used during construction of model

    [patchSize][patchSize] INT colours IS gcolours :


    PROC normalize ( [3] REAL32 vector, REAL32 oldHyp )
      REAL32 t :
      SEQ
        t :=  (vector [0] * vector [0]) +
             ((vector [1] * vector [1]) +
              (vector [2] * vector [2]))
        oldHyp := SQRT( t )
        vector [0] := vector [0] / oldHyp
        vector [1] := vector [1] / oldHyp
        vector [2] := vector [2] / oldHyp
    :

    [256] INT message :
    INT mess.p :

    PROC wrch ( VAL INT ch )
      IF
        ch = (-7)
          SEQ
            pixelsOut ! c.message; mess.p; [ message FROM 0 FOR mess.p ]
            mess.p := 0
        mess.p = 256
          SKIP
        TRUE
          SEQ
            message [ mess.p] := ch
            mess.p := mess.p + 1
    :


    PROC writen ( VAL INT num)
      [20] INT stack :
      INT sp :
      PROC push (VAL INT push)
        SEQ
          stack[sp] := push
          sp := sp + 1
          SKIP
      :

      PROC pop (INT pop)
        SEQ
          sp := sp - 1
          pop := stack[sp]
          SKIP
      :

      VAL nil IS #DEAD :
      INT n :
      SEQ
        IF
          num < 0
            SEQ
              n := -num
              wrch ( INT '-')
          TRUE
            n := num
        sp := 0
        push (nil)
        WHILE n > 9
          SEQ
            push (n \ 10)
            n := n / 10
        WHILE n <> nil
          SEQ
            wrch ( n + (INT '0'))
            pop (n)
    :


    PROC writeReal ( VAL INT X )
      --Write real number X to channel OUT. Number has IP places of
      --figures before point, DP places after; sign is either space or minus.
      --Total field width is Ip+Dp+2. If value out of range then
      --exponential form used. If Dp is zero then free format using
      --minimum field width is used (exponential form if number out
      --of sensible range), Ip should be zero if Dp is zero. If Ip is
      --zero then the exponential form is used to give Dp places of
      --accuracy (field width is Dp+6). In exponential form the
      --fraction (.1 <= f < 1.) is followed be E, sign (+, -) and the
      --two digit exponent.
      -- IEEE Standard Floating Point Arithmetic.
      -- Single length implementation for 32 bit host.
      -- Martin Bond, Version 6, 16 April 85.

      -- Standard operation routines

      VAL RealShift      IS         8 :
      VAL RealExpSh      IS        23 :
      VAL BitsInFrac     IS        24 :
      VAL RealExp        IS       255 :
      VAL RealXcess      IS       127 :
      VAL RealRBit       IS       128 :
      VAL RealInf        IS #7F800000 :
      VAL RealNaN        IS #7F800001 :
      VAL SignBit        IS #80000000 :
      VAL BitsPerWord    IS        32 :
      --square root constants
      VAL R2C            IS #93000000 :
      VAL R2K            IS #6CFFFFFF :      --word extension always -1
      VAL R2R            IS #B504F334 :

      -- Useful constants.
      VAL RealMin        IS #00800000 :      --min normal number
      VAL RealMax        IS #7F7FFFFF :      --max normal integer
      VAL One            IS #3F800000 :      --unity

      VAL Pi             IS #40490FDB :
      VAL E              IS #402DF854 :
      VAL add IS 0 :
      VAL sub IS 1 :
      VAL mul IS 2 :
      VAL div IS 3 :
      VAL rem IS 4 :
      -- write number constants
      VAL RealBuf        IS     8 :             --buffer size

      VAL Table10        IS    13 :             --exact power ten in word
      VAL Bias10         IS     3 :             --extras for full pow ten range
      VAL MaxDecN        IS     9 :             --maximum dec digits
      VAL R2L            IS #4D10 :             --Log2(10) in low half word

      VAL PowerTenFrac IS [#80000000,
                       #A0000000,
                       #C8000000,
                       #FA000000,
                       #9C400000,
                       #C3500000,
                       #F4240000,
                       #98968000,
                       #BEBC2000,
                       #EE6B2800,
                       #9502F900,
                       #BA43B740,
                       #E8D4A510,
                       #9184E72A] :

      VAL PowerTenExp  IS [0, 3, 6, 9, 13, 16, 19, 23, 26, 29, 33, 36, 39, 43] :

      VAL BiasTenFrac  IS [#9184E72A,     --P13
                      #CECB8F28,     --P27
                      #EB194F8E] :   --P40

      VAL BiasTenExp   IS [43, 89, 132] :

      VAL BiasTen      IS [14, 28, 41, 54] :  --bias changeover points


      PROC put.byte ( VAL INT byte )
        wrch ( byte)
      :

      PROC ScaleX (INT Xexp, Xfrac, VAL INT Scale)
        --scale x by value of 10^Scale
        INT Carry, Places, Sb, St, Zexp, Zfrac :
        SEQ
          IF
            Scale < 0                           --get abs value of scale
              St := -Scale
            TRUE
              St := Scale
          IF
            St <= Table10                       --easy case, 10 in table
              SEQ
                Zexp := PowerTenExp[St]
                Zfrac := PowerTenFrac[St]
            St = (BiasTen[1]-1)                 --special case
              SEQ
                Zexp := BiasTenExp[1]
                Zfrac := BiasTenFrac[1]
            TRUE                                --apply bias
              SEQ
                IF                              --get power ten bias
                  IF i = 0 FOR Bias10
                    St < BiasTen[i+1]
                      Sb := i
                  TRUE                          --too big
                    Sb := -1
                IF
                  Sb < 0                        --too large
                    Zexp := -1
                  TRUE                          --valid power
                    SEQ
                      St := (St-BiasTen[Sb]) + 1
                      Zexp := (PowerTenExp[St]+BiasTenExp[Sb]) + 1
                      Zfrac, Carry := LONGPROD (PowerTenFrac[St],
                                                  BiasTenFrac[Sb], 0)
                      Places, Zfrac, Carry := NORMALISE (Zfrac, Carry)
                      Zexp := Zexp - Places
          IF
            Zexp < 0                              --out of range
              SEQ
                IF
                  Scale < 0                      --set to big number
                    Zexp := -RealExp
                  TRUE
                    Zexp := RealExp
                Zfrac := SignBit                  --prevent normalisation
            Scale < 0                             --scale down
              SEQ
                Zexp := Xexp - Zexp
                Zfrac, Carry := LONGDIV (Xfrac>>1, 0, Zfrac)
                IF
                  Carry = 0                       --get error in result
                    SEQ
                  TRUE                            --note sticky bit
                    Carry := SignBit
            TRUE                                  --scale up
              SEQ
                Zexp := (Xexp+Zexp) + 1
                Zfrac, Carry := LONGPROD (Xfrac, Zfrac, 0)
          Places, Xfrac, Carry := NORMALISE (Zfrac, Carry)
          Xexp := Zexp - Places
      :

      PROC QuickLog (INT LogX, VAL INT Xexp, Xfrac)
        --cheap approximation of Log10, may be 1 too small.
        INT Borrow, Carry, X :
        SEQ
          --get cheap approx to Log2 of 1.f*2^e as e.f
          Carry, X := SHIFTRIGHT (Xexp, Xfrac<<1, BitsPerWord/2)
          IF
            X < 0                                     --log2 may be small
              SEQ
                X, Carry := LONGPROD (-X, R2L+1, 0)
                Borrow, Carry := LONGDIFF (0, Carry, 0)
                Borrow, LogX := LONGDIFF (0, X, Borrow)
            TRUE                                      --log2 about right
              LogX, Carry := LONGPROD (X, R2L, 0)       --mul by Log10(2)
      :

      PROC Round (INT Xexp, Xfrac, Xint)
        --round number to nearest integer
        INT Places, Guard :
        SEQ
          IF
            Xexp >= BitsPerWord                   --outside valid range
              SEQ
            TRUE                                  --round X to an integer
              SEQ
                Places := BitsPerWord - (Xexp+1)
                Xint, Guard := SHIFTRIGHT (Xfrac, 0, Places)
                IF
                  ((Guard /\ SignBit) = 0) OR     --don't round
                    (((Guard/\(~SignBit))\/(Xint/\1)) = 0)
                    SKIP                          --round down/even
                  TRUE
                    Xint := Xint + 1              --round integer
                Guard, Xfrac := SHIFTLEFT (0, Xint, Places)   --get int as real
                Xexp := Xexp + Guard
      :

      PROC WriteDec ([]INT Buf, INT Length, VAL INT Num)
        --generate unsigned number (assumed to be non-zero)
        INT N, ix, iy :
        SEQ
          N := Num
          ix := 0                           --build in reverse order
          WHILE N <> 0
            SEQ
              INT temp :
              SEQ
                N, temp := LONGDIV (0, N, 10)
                Buf[ix] := temp
              IF
                (ix\/Buf[ix]) = 0           --dump trailing spaces
                  SKIP
                TRUE
                  SEQ
                    Buf[ix] := Buf[ix] + (INT '0')
                    ix := ix + 1
          Length := ix
          ix := ix - 1
          iy := 0
          WHILE iy < ix                     --get correct order
            SEQ
              N := Buf[ix]
              Buf[ix] := Buf[iy]
              Buf[iy] := N
              iy := iy + 1
              ix := ix - 1
      :

      INT Ip, Dp :
      INT Carry, LogX, N, Places, Scale :
      INT Xexp, Xfrac, Xint, Yexp, Yfrac :
      [MaxDecN]INT Buf :
      SEQ
        Ip := 0
        Dp := 0
        Xexp, Xfrac := SHIFTLEFT(0, X/\(~SignBit), RealShift+1)
        IF
          Xexp = RealExp                    --inf or NaN
            SEQ
              IF
                (X /\ SignBit) = 0
                  put.byte (INT ' ')
                TRUE
                  put.byte (INT '-')
              IF
                X = RealNaN
                  SEQ
                    put.byte (INT 'N')
                    put.byte (INT 'a')
                    put.byte (INT 'N')
                TRUE
                  SEQ
                    put.byte (INT 'I')
                    put.byte (INT 'n')
                    put.byte (INT 'f')
              IF
                Dp <> 0                     --pad with spaces
                  SEQ i = 0 FOR (Ip+Dp)-2
                    put.byte (INT ' ')
                TRUE
                  SEQ
              IF
                (Ip = 0) AND (Dp <> 0)      --exp form
                  SEQ
                    put.byte (INT ' ')      --for e+00
                    put.byte (INT ' ')
                    put.byte (INT ' ')
                    put.byte (INT ' ')
                TRUE
                  SEQ
          (Xexp\/Xfrac) = 0                 --zero
            SEQ
              IF
                (X /\ SignBit) = 0
                  put.byte (INT ' ')
                TRUE
                  put.byte (INT '-')
              SEQ i = 0 FOR Ip-1
                put.byte (INT ' ')
              put.byte (INT '0')
              put.byte (INT '.')
              put.byte (INT '0')
              SEQ i = 0 FOR Dp-1
                put.byte (INT ' ')
          TRUE                              --proper value
            SEQ
              IF
                Xexp = 0                    --ensure normal
                  SEQ
                    Places, Xfrac, Carry := NORMALISE (Xfrac, 0)
                    Xexp := - (Places + RealXcess)
                TRUE                        --set top bit
                  SEQ
                    Xfrac := (Xfrac >> 1) \/ SignBit
                    Xexp := Xexp - RealXcess
              Yexp := Xexp                  --save extended X
              Yfrac := Xfrac
              QuickLog (LogX, Xexp, Xfrac)  --get log
              IF
                Dp <> 0                     --field width
                  SEQ
                    N := Ip + Dp            --significant digits
                    IF
                      N > MaxDecN           --don't print too many
                        N := MaxDecN
                      TRUE
                        SEQ
                TRUE
                  N := MaxDecN              --default
              Scale := (N - 1) - LogX
              ScaleX (Xexp, Xfrac, Scale)   --get X in range
              Round (Xexp, Xfrac, Xint)     --now as integer
              IF
                (Xexp > PowerTenExp[N]) OR
                  ((Xexp = PowerTenExp[N]) AND (Xfrac >= PowerTenFrac[N]))
                  SEQ
                    LogX := LogX + 1        --new scale
                    Xexp := Yexp            --reset X
                    Xfrac := Yfrac
                    ScaleX (Xexp, Xfrac, Scale-1)
                    Round (Xexp, Xfrac, Xint)
                TRUE                        --X in correct range
                  SEQ
              WriteDec (Buf, Places, Xint)         --get number string
              IF
                (Dp = 0) AND ((-3) <= LogX) AND (LogX < N)  --good default form
                  SKIP
                (Ip = 0) OR (LogX >= Ip) OR
                  ((-LogX) > Dp)            --use exp form
                  SEQ
                    IF
                      (X /\ SignBit) = 0
                        put.byte (INT ' ')
                      TRUE
                        put.byte (INT '-')
                    put.byte (Buf[0])
                    put.byte (INT '.')
                    IF
                      Dp <> 0               --exp form requested
                        SEQ
                          SEQ i = 1 FOR Dp-1
                            IF
                              i < Places
                                put.byte (Buf[i])
                              i = 1         --only one digit
                                put.byte (INT '0')
                              TRUE          --space fill field
                                put.byte (INT ' ')
                      Places <= 1           --only one digit
                        put.byte (INT '0')
                      TRUE                  --output all digits
                        SEQ i = 1 FOR Places-1
                          put.byte (Buf[i])
                    put.byte (INT 'E')
                    IF
                      LogX < 0
                        SEQ
                          put.byte (INT '-')
                          LogX := -LogX
                      TRUE
                        put.byte (INT '+')
                    put.byte ((LogX/10) + (INT '0'))
                    put.byte ((LogX\10) + (INT '0'))
                    Places := 0             --flag done
                TRUE
                  SKIP
              IF
                Places = 0                  --number already output
                  SKIP
                TRUE                        --output number
                  INT Ipl, Dpl :
                  SEQ
                    IF
                      LogX <= 0                  --always 0.
                        Scale := 0
                      TRUE
                        Scale := LogX
                    IF
                      Dp = 0                     --free format
                        SEQ
                          IF
                            LogX < 0
                              Ipl := 1             --sign and 0.
                            TRUE
                              Ipl := LogX + 1
                          Dpl := Places - LogX
                          IF
                            Dpl <= 0
                              Dpl := 1
                            TRUE
                              SEQ
                      TRUE
                        SEQ
                          Ipl := Ip
                          Dpl := Dp
                    SEQ i = LogX-Ipl FOR Ipl+1
                      IF
                        ((i = LogX) AND (LogX < 0)) OR (i >= Places)
                          put.byte (INT '0')
                        i = (LogX-(Scale+1))
                          IF
                            (X /\ SignBit) = 0
                              put.byte (INT ' ')
                            TRUE
                              put.byte (INT '-')
                        i < (-1)
                          put.byte (INT ' ')
                        (0 <= i) AND (i < Places)
                          put.byte (Buf[i])
                    put.byte (INT '.')
                    SEQ i = (LogX+1) FOR Dpl
                      IF
                        ((i = (LogX+1)) AND (i >= Places)) OR (i < 0)
                          put.byte (INT '0')
                        (0 <= i) AND (i < Places)
                          put.byte (Buf[i])
                        i >= Places
                          put.byte (INT ' ')
    :

    PROC writef ( VAL [] BYTE str, VAL INT a, b, c, d)
      INT chptr, ch, ptr :
      [4] INT args :
      SEQ
        ptr     := 0
        chptr   := 0
        args[0] := a
        args[1] := b
        args[2] := c
        args[3] := d
        WHILE chptr < (SIZE str)
          SEQ
            ch := INT str[chptr]
            IF
              ch = (INT '%')
                SEQ
                  chptr := chptr + 1
                  ch := INT str [chptr]
                  IF
                    (ch = (INT 'I')) OR (ch = (INT 'i'))
                      SEQ
                        writen ( args[ptr])
                        IF
                          ptr = 3
                            SKIP
                          TRUE
                            ptr := ptr + 1
                    (ch = (INT 'F')) OR (ch = (INT 'f'))
                      SEQ
                        writeReal ( args[ptr])
                        IF
                          ptr = 3
                            SKIP
                          TRUE
                            ptr := ptr + 1
                    TRUE
                      SKIP

              TRUE
                wrch ( ch)
            chptr := chptr + 1
        wrch ( -7)
    :


    VAL ticksPerSecond IS 625000 / 64 :  -- lo priority
    INT command :
    INT nrays, nobj, nlight, secs, ticks, then :
    TIMER TIME :
    SEQ
      secs    := 0
      ticks   := 0
      TIME ? then
      nrays   := 0
      nobj    := 0
      nlight  := 0
      command := 0         -- clear command for when i move to bytes
      world.p := 0         -- empty world model
      light.p := 0         -- and lights list
      mess.p  := 0         -- clear debug message
      workIn ? command     -- (eventually) pull in 1 byte
      WHILE command <> c.stop
        SEQ
          IF
            command = c.render
              INT x0, y0 :
              SEQ
                workIn ? x0; y0
                writef ( "Worker %I done on %I %I", me, x0, y0, 0 )
                pixelsOut ! c.patch; x0; y0; runPatchSize
                SEQ y = 0 FOR runPatchSize
                  pixelsOut ! [ colours [y] FROM 0 FOR runPatchSize ]
                done ! 42
            command = c.object
              SEQ
                nobj := nobj + 1
                workIn ? worldModel [ world.p];
                       [ worldModel FROM world.p + 1 FOR worldModel [ world.p]]
                world.p := world.p + (worldModel [ world.p] + 1)
            command = c.light
              REAL32 hyp :
              SEQ
                nlight := nlight + 1
                workIn ? lights [ light.p] ;
                       [ lights FROM light.p + 1 FOR lights [ light.p]]
                normalize ( [ flights FROM light.p + (l.dx + 1) FOR 3 ], hyp )
                light.p := light.p + (lights [ light.p] + 1)
            command = c.runData
              INT size :
              SEQ
                workIn ? size; [ runData FROM 0 FOR size ]
                lights     [ light.p] := nil
                worldModel [ world.p] := nil
            TRUE
              SEQ
                writef ( "Worker %I received garbage command %I", me, command, 0,0)
                STOP
          INT now, delay :
          SEQ
            TIME ? now
            delay := now MINUS then
            IF
              delay > ticksPerSecond
                SEQ
                  secs  := secs + (delay / ticksPerSecond)
                  ticks := delay \ ticksPerSecond
                  then  := now PLUS ticks
              TRUE
                SKIP
          workIn ? command
      writef ( "Worker %I DONE in %I seconds, scene of %I objects",
        me, secs, nobj, 0 )
      writef ( "Worker %I, %I lights traced %I rays", me, nlight, nrays, 0 )
      pixelsOut ! command
  :

  CHAN OF ANY feedPixels, pixelTrigger, pixelsOut :

  [4][256] INT buffers :

  WHILE TRUE
    PRI PAR
      PAR
        throughPut  ( buffers [0],
                      fromPrev, toNext, feedPixels, pixelTrigger,
                      propogate )
        pixelBypass ( [ buffers FROM 0 FOR 3], toPrev, fromNext,  pixelsOut )
      renderer   ( feedPixels, pixelsOut, pixelTrigger )
:


