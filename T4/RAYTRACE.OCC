PROC rayTrace   ( CHAN OF ANY fromPrev, toPrev, fromNext, toNext,
                    VAL INT propogate, me )

  #USE "occama.lib"     --T414 math library
  --#USE "occam8.lib"     --T8xx math library

  VAL c.stop    IS 0 :
  VAL c.render  IS 1 :  -- render; x0; y0
  VAL c.object  IS 2 :  -- object; size; [ size ]
  VAL c.light   IS 3 :  -- light;  size; [ size ]
  VAL c.patch   IS 4 :  -- patch;  x; y; patchSize; [ patchSize][patchSize]
  VAL c.runData IS 5 :  -- ambient light, rendering mode, screen pos etc.
  VAL c.message IS 6 :  -- message; size; [ words ]

  VAL nil       IS -1 :

  VAL n.red   IS 18 :
  VAL n.green IS 19 :
  VAL n.blue  IS 20 :

  VAL nodeSize IS n.blue + 1 :

  VAL maxDepth IS 6 :
  VAL maxNodes IS 4 + (2 << maxDepth) :  -- traverse tree 5 deep max,
                                         -- PLUS 4 for good measure
  VAL treeSize  IS nodeSize * maxNodes : -- shadow generation

  -- the attribute word contains gross attributes of the object as
  -- bits. The relevant words in the object descriptor expand upon these

  VAL a.spec     IS #01 :  -- use lambert / use phong and reflect
  VAL a.frac     IS #02 :  -- refract on surface
  VAL a.bound0   IS #04 :  -- bounded in 1 dimension
  VAL a.bound1   IS #08 :  -- bounded in 2 dimension
  VAL a.tex      IS #10 :  -- texture map ?
  VAL a.bump     IS #20 :  -- bump map    ?

  VAL o.type     IS  0 : -- type field of all objects
  VAL o.attr     IS  1 : -- attribute field of all object

  VAL o.kdR      IS  2 :  -- coeffs of diffuse reflection R G B
  VAL o.kdG      IS  3 :
  VAL o.kdB      IS  4 :

  VAL o.ks       IS  5 :  -- coeff of specular reflection ( for reflections)

  VAL o.kg       IS  6 :  -- coeff of gloss for phong shading
  VAL o.xmitR    IS  7 :  -- coeffs of transmission R G B
  VAL o.xmitG    IS  8 :
  VAL o.xmitB    IS  9 :

  VAL o.power    IS 10 :  -- power for phong shading
  VAL o.refix    IS 11 :  -- refractive index (relative)

  VAL o.specific IS 12 :

  VAL first      IS o.specific :

  VAL s.rad      IS  first + 0 :
  VAL s.x        IS  first + 1 :
  VAL s.y        IS  first + 2 :
  VAL s.z        IS  first + 3 :

  VAL s.map      IS  first + 4 :  -- which map ( texture or bump)
  VAL s.uoffs    IS  first + 5 :  -- offsets for u and v in map
  VAL s.voffs    IS  first + 6 :
  VAL s.size     IS  first + 7 :
  VAL sizeWorld IS 1800 :  -- a sphere = 17 words + nextPtr,
                           -- giving 100 spheres

  VAL l.ir   IS 0 :   -- light intensity fields  R G B
  VAL l.ig   IS 1 :
  VAL l.ib   IS 2 :

  VAL l.dx   IS 3 :   -- light direction cosines x y z
  VAL l.dy   IS 4 :   -- this is a quick'n'tacky shading sheme
  VAL l.dz   IS 5 :

  VAL l.size IS 6 :

  -- each light is |nextPtr|r|g|b|dx|dy|dz

  VAL sizeLight  IS  7 :

  VAL maxLights  IS 10 :   -- any more than 2 is hell to shade !!

  VAL sizeLights IS sizeLight * maxLights :

  VAL maxDescend   IS 2 :    -- this is a space limitation on the sub-pixel
                             -- grid rather than a compute saver
  VAL descendPower IS 4 :    -- 2 ^^ maxDescend

  VAL patchSize IS 16 :
  VAL gridSize  IS ((patchSize + 1) * descendPower) + 1 :

  VAL mint  IS MOSTNEG INT :

  -- colours are nr | 10 blue bits | 10 green bits | 10 red bits |

  VAL threshold   IS 10 << 2 : -- this is 10 on a scale of 256, but we
  VAL colourBits  IS 10 :      -- generate 10 bits

  VAL rMask       IS (1 << colourBits) - 1 :
  VAL gMask       IS rMask    << colourBits :
  VAL bMask       IS gMask    << colourBits :

  VAL rMaxDiff    IS threshold :               -- threshold values for
  VAL gMaxDiff    IS rMaxDiff << colourBits :  -- instancing super sample
  VAL bMaxDiff    IS gMaxDiff << colourBits :

  VAL notRendered IS mint :  -- top bit set = not rendered



  PROC throughPut ( [256] INT work,
                    CHAN OF ANY fromPrev, toNext, feedPixels, pixelTrigger,
                    VAL INT propogate )

    VAL closeDown     IS 0 :
    VAL active        IS 1 :
    VAL busy          IS 2 :
    VAL buffered      IS 4 :

    INT state, tag :
    INT x, y, size, kick :
    SEQ
      state := active
      WHILE state <> closeDown
        PRI ALT
          pixelTrigger ? kick  -- should be guarded by (state /\ busy) <> 0 ..
            IF
              (state /\ buffered) <> 0
                SEQ
                  feedPixels ! c.render; x; y
                  state := active \/ busy
              TRUE
                state := active -- i.e not busy and not buffered
          fromPrev ? tag
            IF
              tag = c.render
                INT a, b :
                SEQ
                  fromPrev ? a; b
                  IF
                    (state /\ busy) = 0
                      SEQ
                        feedPixels ! tag; a; b
                        state := active \/ busy

                    (state /\ buffered) <> 0
                      toNext ! tag; a; b
                    TRUE
                      SEQ
                        x     := a
                        y     := b
                        state := active \/ (busy \/ buffered)
              tag = c.stop
                SEQ
                  IF
                    (state /\ busy) <> 0
                      pixelTrigger ? kick
                    TRUE
                      SKIP
                  IF
                    (state /\ buffered) <> 0
                      SEQ
                        feedPixels   ! c.render; x; y
                        pixelTrigger ? kick
                    TRUE
                      SKIP
                  feedPixels ! tag
                  toNext     ! tag
                  state := closeDown
              TRUE
                SEQ
                  fromPrev ? size; [ work FROM 0 FOR size ]
                  IF
                    propogate <> 0
                      toNext ! tag; size; [ work FROM 0 FOR size ]
                    TRUE
                      SKIP
                  feedPixels ! tag; size; [ work FROM 0 FOR size ]
  :



  PROC pixelBypass ( [3][256] INT buffers,
                     CHAN OF ANY toPrev, fromNext, fromThis)
    PROC buffer ( [256] INT pixels, CHAN OF ANY in, out )
      INT command :
      SEQ
        in ? command
        WHILE command <> c.stop
          INT x, y, size :
          SEQ
            IF
              command = c.patch
                SEQ
                  in  ? x; y; size
                  out ! command; x; y; size
                  SEQ i = 0 FOR size
                    SEQ
                      in  ? [ pixels FROM 0 FOR size ]
                      out ! [ pixels FROM 0 FOR size ]
              command = c.message
                SEQ
                  in  ? size; [ pixels FROM 0 FOR size ]
                  out ! command; size; [ pixels FROM 0 FOR size ]
            in ? command
        out ! c.stop
    :


    PROC mix ( [256] INT pixels, CHAN OF ANY fromOther, fromThis, out)
      INT  state, command, x, y, size :

      VAL closeDown  IS 0 :
      VAL lubThis    IS 1 :
      VAL lubOther   IS 2 :

      PROC pass ( CHAN OF ANY in, out )
        buffer IS pixels : -- save static chaining
        SEQ i = 0 FOR size
          SEQ
            in  ? [ buffer FROM 0 FOR size ]
            out ! [ buffer FROM 0 FOR size ]
      :
      SEQ
        state := lubThis \/ lubOther
        WHILE state <> closeDown
          PRI ALT
            fromOther ? command
              SEQ
                IF
                  command = c.message
                    SEQ
                      fromOther ? size; [ pixels FROM 0 FOR size ]
                      out ! command; size; [ pixels FROM 0 FOR size ]
                  command = c.patch
                    SEQ
                      fromOther ? x; y; size
                      out ! command; x; y; size
                      pass ( fromOther, out )
                  command = c.stop
                    state := state >< lubOther
            fromThis ? command
              SEQ
                IF
                  command = c.message
                    SEQ
                      fromThis ? size; [ pixels FROM 0 FOR size ]
                      out ! command; size; [ pixels FROM 0 FOR size ]
                  command = c.patch
                    SEQ
                      fromThis ? x; y; size
                      out ! command; x; y; size
                      pass ( fromThis, out )
                  command = c.stop
                    state := state >< lubThis
        out ! c.stop
    :

    CHAN OF ANY lubThis, lubOther :
    PAR
      buffer ( buffers [0], fromNext, lubOther)
      buffer ( buffers [1], fromThis, lubThis)
      mix    ( buffers [2], lubOther, lubThis, toPrev)
  :


  
  [20] INT grunData :


  [sizeWorld] INT    gworldModel :

  [sizeLights] INT glights :
  [patchSize][patchSize] INT gcolours : -- these are the AREA-AVERAGED colours
                                        -- returned to the grafix cards,
                                        -- not the point samples



  PROC renderer ( CHAN OF ANY workIn, pixelsOut, done )
    [20] INT runData IS grunData :

    runPatchSize  IS runData [4] :

    [sizeWorld] INT worldModel IS gworldModel :

    INT world.p :  -- pointer used during construction of model
    [sizeLights] INT lights IS glights :
    [sizeLights] REAL32 flights RETYPES lights :

    INT light.p :  -- pointer used during construction of model

    [patchSize][patchSize] INT colours IS gcolours :


    PROC normalize ( [3] REAL32 vector, REAL32 oldHyp )
      REAL32 t :
      SEQ
        t :=  (vector [0] * vector [0]) +
             ((vector [1] * vector [1]) +
              (vector [2] * vector [2]))
        oldHyp := SQRT( t )
        vector [0] := vector [0] / oldHyp
        vector [1] := vector [1] / oldHyp
        vector [2] := vector [2] / oldHyp
    :

    [256] INT message :
    INT mess.p :

    PROC wrch ( VAL INT ch )
      IF
        ch = (-7)
          SEQ
            pixelsOut ! c.message; mess.p; [ message FROM 0 FOR mess.p ]
            mess.p := 0
        mess.p = 256
          SKIP
        TRUE
          SEQ
            message [ mess.p] := ch
            mess.p := mess.p + 1
    :


    PROC writen ( VAL INT num)
      [20] INT stack :
      INT sp :
      PROC push (VAL INT push)
        SEQ
          stack[sp] := push
          sp := sp + 1
          SKIP
      :

      PROC pop (INT pop)
        SEQ
          sp := sp - 1
          pop := stack[sp]
          SKIP
      :

      VAL nil IS #DEAD :
      INT n :
      SEQ
        IF
          num < 0
            SEQ
              n := -num
              wrch ( INT '-')
          TRUE
            n := num
        sp := 0
        push (nil)
        WHILE n > 9
          SEQ
            push (n \ 10)
            n := n / 10
        WHILE n <> nil
          SEQ
            wrch ( n + (INT '0'))
            pop (n)
    :

    PROC writef ( VAL [] BYTE str, VAL INT a, b, c, d)
      INT chptr, ch, ptr :
      [4] INT args :
      SEQ
        ptr     := 0
        chptr   := 0
        args[0] := a
        args[1] := b
        args[2] := c
        args[3] := d
        WHILE chptr < (SIZE str)
          SEQ
            ch := INT str[chptr]
            IF
              ch = (INT '%')
                SEQ
                  chptr := chptr + 1
                  ch := INT str [chptr]
                  IF
                    (ch = (INT 'I')) OR (ch = (INT 'i'))
                      SEQ
                        writen ( args[ptr])
                        IF
                          ptr = 3
                            SKIP
                          TRUE
                            ptr := ptr + 1
                    TRUE
                      SKIP

              TRUE
                wrch ( ch)
            chptr := chptr + 1
        wrch ( -7)
    :


    VAL ticksPerSecond IS 625000 / 64 :  -- lo priority
    INT command :
    INT nrays, nobj, nlight, secs, ticks, then :
    TIMER TIME :
    SEQ
      secs    := 0
      ticks   := 0
      TIME ? then
      nrays   := 0
      nobj    := 0
      nlight  := 0
      command := 0         -- clear command for when i move to bytes
      world.p := 0         -- empty world model
      light.p := 0         -- and lights list
      mess.p  := 0         -- clear debug message
      workIn ? command     -- (eventually) pull in 1 byte
      WHILE command <> c.stop
        SEQ
          IF
            command = c.render
              INT x0, y0 :
              SEQ
                workIn ? x0; y0
                writef ( "Worker %I done on %I %I", me, x0, y0, 0 )
                pixelsOut ! c.patch; x0; y0; runPatchSize
                SEQ y = 0 FOR runPatchSize
                  pixelsOut ! [ colours [y] FROM 0 FOR runPatchSize ]
                done ! 42
            command = c.object
              SEQ
                nobj := nobj + 1
                workIn ? worldModel [ world.p];
                       [ worldModel FROM world.p + 1 FOR worldModel [ world.p]]
                world.p := world.p + (worldModel [ world.p] + 1)
            command = c.light
              REAL32 hyp :
              SEQ
                nlight := nlight + 1
                workIn ? lights [ light.p] ;
                       [ lights FROM light.p + 1 FOR lights [ light.p]]
                normalize ( [ flights FROM light.p + (l.dx + 1) FOR 3 ], hyp )
                light.p := light.p + (lights [ light.p] + 1)
            command = c.runData
              INT size :
              SEQ
                workIn ? size; [ runData FROM 0 FOR size ]
                lights     [ light.p] := nil
                worldModel [ world.p] := nil
            TRUE
              SEQ
                writef ( "Worker %I received garbage command %I", me, command, 0,0)
                STOP
          INT now, delay :
          SEQ
            TIME ? now
            delay := now MINUS then
            IF
              delay > ticksPerSecond
                SEQ
                  secs  := secs + (delay / ticksPerSecond)
                  ticks := delay \ ticksPerSecond
                  then  := now PLUS ticks
              TRUE
                SKIP
          workIn ? command
      writef ( "Worker %I DONE in %I seconds, scene of %I objects",
        me, secs, nobj, 0 )
      writef ( "Worker %I, %I lights traced %I rays", me, nlight, nrays, 0 )
      pixelsOut ! command
  :

  CHAN OF ANY feedPixels, pixelTrigger, pixelsOut :

  [4][256] INT buffers :

  WHILE TRUE
    PRI PAR
      PAR
        throughPut  ( buffers [0],
                      fromPrev, toNext, feedPixels, pixelTrigger,
                      propogate )
        pixelBypass ( [ buffers FROM 0 FOR 3], toPrev, fromNext,  pixelsOut )
      renderer   ( feedPixels, pixelsOut, pixelTrigger )
:


