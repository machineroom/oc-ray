--{{{  #USE and #INCLUDEs
#INCLUDE "hostio.inc"
#USE "hostio.lib"

#INCLUDE "cgilib.inc"
#USE "cgilib.lib"

#INCLUDE "video.inc"
--}}}

PROC example( CHAN OF SP fs, ts, []INT free.mem )
  --{{{  VARs
  INT gsb, static.size :
  CHAN OF CGI to.cgi, from.cgi :
  --}}}
  SEQ
    --{{{  Setup static and heap areas
    init.static( [ free.mem FROM 0 FOR 0 ], static.size, gsb )
    IF
      ( static.size > (SIZE free.mem) )
        SEQ
          so.write.string.nl( fs, ts, "No memory for CGI statics" )
          so.exit( fs, ts, sps.failure )
          CAUSEERROR()  -- Stop the transputer
      TRUE
        static.area IS [ free.mem FROM 0 FOR static.size ] :
        heap.area IS [ free.mem FROM static.size FOR 
                                     (SIZE free.mem) - static.size ] :
        SEQ
          INT unused.size :
          init.static( static.area, unused.size, gsb )
          init.heap( gsb, heap.area )
    --}}}
    PAR
      --{{{  Example CGI application
      --{{{  VARs
      VAL bank IS 0 :
      
      BOOL font.ok :
      [VTG.SIZE]INT v :
      [SCREEN.SIZE]INT s :
      [maxErrString]BYTE errmsg :
      INT errqual, errmsg.len, errno :
      --}}}
      
      --{{{  palette
      PROC palette()
        INT colour :
        SEQ
          colour := 0
          SEQ clutloc = 0 FOR 64
            SEQ
              colour := clutloc * 4
              fs.setpalette( to.cgi, clutloc,     colour, colour, colour )  -- grey  scale 
              fs.setpalette( to.cgi, clutloc+64,  colour, 0,      0 )       -- red   scale 
              fs.setpalette( to.cgi, clutloc+128, 0,      colour, 0 )       -- green scale 
              fs.setpalette( to.cgi, clutloc+192, 0,      0,      colour )  -- blue  scale 
      :
      --}}}
      --{{{  box.there
      BOOL FUNCTION box.there( VAL INT x, y )
        BOOL box :
        VAL x.missing IS [ 0, 1, 0, 0, 1, 0, 7, 7 ] :
        VAL y.missing IS [ 0, 0, 1, 7, 7, 6, 6, 7 ] :
        VALOF
          IF 
            IF i = 0 FOR 8
              ( ( (x.missing[i] = x) AND (y.missing[i] = y) ) OR
                ( (y.missing[i] = x) AND (x.missing[i] = y) ) )
                box := FALSE
            TRUE
              box := TRUE
          RESULT box
      :
      --}}}
      --{{{  logo
      PROC logo( VAL INT x0, y0, rad, fg.col, bg.col )
        INT box.edge, hole.edge, xc, yc, xt, yt :
        SEQ
          box.edge := rad / 5
          hole.edge := rad / 39
          xc := (x0 + rad) + 9
          yc := (y0 + rad) + 9
          cgi.setfcol( to.cgi, bg.col )
          cgi.fcircle( to.cgi, xc, yc, rad, rad )
          VAL x0 IS ( xc - (box.edge << 2 ) ) - ( (hole.edge * 7) / 2 ) :
          VAL y0 IS ( yc - (box.edge << 2 ) ) - ( (hole.edge * 7) / 2 ) :
          SEQ x = 0 FOR 8
            SEQ y = 0 FOR 8
              IF
                ( box.there( x, y ) )
                  SEQ
                    xt := x0 + ( (box.edge+hole.edge) * x )
                    yt := y0 + ( (box.edge+hole.edge) * y )
                    cgi.setfcol( to.cgi, fg.col )
                    cgi.frect( to.cgi, xt, yt, xt+box.edge, yt+box.edge )
                TRUE
                  SKIP
      :
      --}}}
      
      VAL text1 IS "inmos ltd" :
      VAL text2 IS "IMS-F003  OCCAM  CGI  Libraries" :
      
      SEQ
      
        v := V.1024.768
      
        cgi.init( to.cgi )
        fs.openboard( to.cgi, v )
      
        fs.initscreen( from.cgi, to.cgi, s, bank )
        so.write.string.nl( fs, ts, "Screen initialised" )
        so.write.string( fs, ts, "raster = " )
        so.write.hex.int( fs, ts, s[SCREEN.RASTER], 8 )
        so.write.string( fs, ts, " xsize = " )
        so.write.int( fs, ts, s[SCREEN.XSIZE], 0 )
        so.write.string( fs, ts, " ysize = " )
        so.write.int( fs, ts, s[SCREEN.YSIZE], 0 )
        so.write.nl( fs, ts )
      
        fs.displaybank( to.cgi, bank )
        palette()
      
        cgi.setdrawscreen( to.cgi, s )
        cgi.setfcol( to.cgi, 127 )
        cgi.cls( to.cgi, s, 255 )
      
        SEQ loop1 = 0 FOR 256
          SEQ
            cgi.setfcol( to.cgi, loop1 )
            SEQ loop2 = 0 FOR 4
              cgi.line( to.cgi, (loop1*4)+loop2, 0, (loop1*4)+loop2, 767 )
      
        cgi.setdrawmode( to.cgi, PM.COL, RM.XOR, FM.COL )
        SEQ loop1 = 0 FOR 192
          SEQ
            cgi.setfcol( to.cgi, (4*loop1)/3 )
            SEQ loop2 = 0 FOR 4
              cgi.line( to.cgi, 0, (loop1*4)+loop2, 1023, (loop1*4)+loop2 )
      
        cgi.setdrawmode( to.cgi, PM.COL, RM.COL, FM.COL )
        SEQ loop1 = 0 FOR 192  
          SEQ
            cgi.setfcol( to.cgi, (4*loop1)/3 )
            SEQ loop2 = 0 FOR 2
              cgi.line( to.cgi, 256, (192+loop2)+(loop1*2),
                                768, (192+loop2)+(loop1*2) )
      
        cgi.setfcol( to.cgi, 63 )
        cgi.rect( to.cgi, 256, 192, 768, 576 )
        logo( 270, 200, 100, 40, 20 )
      
        cgi.setfont( from.cgi, to.cgi, FONT.8.BY.8, 
                     font.NCHARS, font.FAMW, font.FWPC, font.FLPW,
                     font.ok )
        IF
          ( NOT font.ok )
            so.write.string.nl( fs, ts, "Failed to load font" )
          TRUE
            SKIP
          
        cgi.setorient( to.cgi, TX.NORM )
        cgi.chrspace( to.cgi, 10, 0 )
      
        cgi.setfcol( to.cgi, 127 )
        cgi.setdrawmode( to.cgi, PM.COL, RM.XOR, FM.COL )
        SEQ loop1 = 0 FOR (SIZE text1)
          SEQ
            cgi.chrbegin( to.cgi, 518+(loop1*23), 426 )
            cgi.chrz( to.cgi, text1[loop1], 20, 20 )
      
        SEQ loop1 = 0 FOR (SIZE text2)
          SEQ
            cgi.chrbegin( to.cgi, 290+(loop1*14), 522 )
            cgi.chrz( to.cgi, text2[loop1], 12, 14 )
      
        cgi.errstat( from.cgi, to.cgi, errmsg, errmsg.len,
                     errno, errqual )
      
        so.write.string( fs, ts, "CGI: error no = " )
        so.write.int( fs, ts, errno, 0 )
        so.write.string( fs, ts, " qual = " )
        so.write.int( fs, ts, errqual, 0 )
        so.write.string( fs, ts, " error = " )
        so.write.string.nl( fs, ts, [ errmsg FROM 0 FOR errmsg.len ] )
      
        fs.closeboard( from.cgi, to.cgi )
      
        cgi.terminate( from.cgi, to.cgi )
      --}}}
      CgiServer( gsb, 0, to.cgi, from.cgi )
    --{{{  Cleanup static and heap areas
    terminate.heap.use( gsb )
    terminate.static.use( gsb )
    --}}}
    so.exit( fs, ts, sps.success )
:
