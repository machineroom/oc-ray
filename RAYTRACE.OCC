PROC rayTrace   ( CHAN OF ANY fromPrev, toPrev, []CHAN OF ANY fromWorkers, []CHAN OF ANY toWorkers,
                    VAL INT propogate, me )

  #USE "occama.lib"     --T414 math library
  --#USE "occam8.lib"     --T8xx math library

  #INCLUDE "PROTOCOL.INC"

  [256] INT message :
  INT mess.p :
  
  -- counts of the number of free workers on each link
  -- max 4 workers (one per link - in practice 1..3)
  [4]INT free.workers:

  PROC wrch ( CHAN OF ANY out, VAL INT ch )
    IF
      ch = (-7)
        SEQ
          out ! c.message; mess.p; [ message FROM 0 FOR mess.p ]
          mess.p := 0
      mess.p = 256
        SKIP
      TRUE
        SEQ
          message [ mess.p] := ch
          mess.p := mess.p + 1
  :


  PROC writen ( CHAN OF ANY out, VAL INT num)
    [20] INT stack :
    INT sp :
    PROC push (VAL INT push)
      SEQ
        stack[sp] := push
        sp := sp + 1
        SKIP
    :

    PROC pop (INT pop)
      SEQ
        sp := sp - 1
        pop := stack[sp]
        SKIP
    :

    VAL nil IS #DEAD :
    INT n :
    SEQ
      IF
        num < 0
          SEQ
            n := -num
            wrch ( out, INT '-')
        TRUE
          n := num
      sp := 0
      push (nil)
      WHILE n > 9
        SEQ
          push (n \ 10)
          n := n / 10
      WHILE n <> nil
        SEQ
          wrch ( out, n + (INT '0'))
          pop (n)
  :

  PROC writef ( CHAN OF ANY out, VAL [] BYTE str, VAL INT a, b, c, d)
    INT chptr, ch, ptr :
    [4] INT args :
    SEQ
      ptr     := 0
      chptr   := 0
      args[0] := a
      args[1] := b
      args[2] := c
      args[3] := d
      WHILE chptr < (SIZE str)
        SEQ
          ch := INT str[chptr]
          IF
            ch = (INT '%')
              SEQ
                chptr := chptr + 1
                ch := INT str [chptr]
                IF
                  (ch = (INT 'I')) OR (ch = (INT 'i'))
                    SEQ
                      writen ( out, args[ptr])
                      IF
                        ptr = 3
                          SKIP
                        TRUE
                          ptr := ptr + 1
                  TRUE
                    SKIP

            TRUE
              wrch ( out, ch)
          chptr := chptr + 1
      wrch ( out, -7)
  :

  #INCLUDE "RENDERER.INC"

  -- accept work from upstream and send it downstream or process locally
  PROC throughPut ( CHAN OF ANY fromPrev, toPrev, []CHAN OF ANY toWorkers, CHAN OF ANY toLocal, localDone,
                    VAL INT propogate )

    VAL closeDown     IS 0 :
    VAL active        IS 1 :
    VAL busy          IS 2 :

    [256] INT buffer :
    INT state, tag :
    INT x, y, size, kick :
    INT n:
    SEQ
      state := active
      WHILE state <> closeDown
        ALT
          localDone ? kick
            SEQ
              --update local state to indicate free for work
              state := active
          fromPrev ? tag
            IF
              tag = c.render
                INT x, y :
                SEQ
                  fromPrev ? x; y
                  IF
                    state = active
                      SEQ
                        toLocal ! tag; x; y
                        state := busy
                    state = busy
                      IF
                        propogate <> 0
                          BOOL cont:
                          INT w:
                          INT max:
                          SEQ
                            cont := TRUE
                            max := SIZE free.workers
                            w := 0
                            -- pass work onto next free worker
                            WHILE cont
                              SEQ
                                IF
                                  free.workers[w] > 0
                                    SEQ
                                      free.workers[w] := free.workers[w] - 1
                                      toWorkers[w] ! tag; x; y
                                      cont := FALSE
                                  TRUE
                                    SKIP
                                w := w + 1
                                IF
                                  w = max
                                    cont := FALSE
                                  TRUE
                                    SKIP
                        TRUE
                          -- not propogate
                          SKIP
                    TRUE
                      SKIP
              tag = c.stop
                SEQ
                  IF
                    state = busy
                      -- wait for local to finish
                      localDone ? kick
                    TRUE
                      SKIP
                  toLocal ! tag
                  IF
                    propogate <> 0
                      SEQ w=0 FOR SIZE toWorkers
                        toWorkers[w] ! tag
                    TRUE
                      SKIP
                  state := closeDown
              TRUE
                SEQ
                  fromPrev ? size; [ buffer FROM 0 FOR size ]
                  IF
                    propogate <> 0
                      SEQ w=0 FOR SIZE toWorkers
                        toWorkers[w] ! tag; size; [ buffer FROM 0 FOR size ]
                    TRUE
                      SKIP
                  toLocal ! tag; size; [ buffer FROM 0 FOR size ]
  :

  -- accept results from local or one of the workers and push the results upstream
  PROC pixelBypass ( CHAN OF ANY out, CHAN OF ANY local, []CHAN OF ANY workers)

    INT  state, command, x, y, size, count, worker :
    [256] INT buffer :

    VAL closeDown  IS 0 :
    VAL busy IS 1 :

    PROC messageHandler (CHAN OF ANY in)
      SEQ
        in ? size; [ buffer FROM 0 FOR size ]
        out ! command; size; [ buffer FROM 0 FOR size ]
    :

    PROC patchHandler (CHAN OF ANY in)
      SEQ
        in ? x; y; size; worker
        out ! command; x; y; size; worker
        SEQ i = 0 FOR size
          SEQ
            in  ? [ buffer FROM 0 FOR size ]
            out ! [ buffer FROM 0 FOR size ]
    :

    SEQ
      state := busy
      WHILE state <> closeDown
        ALT
          local ? command
            IF 
              command = c.message
                messageHandler(local)
              command = c.patch
                patchHandler(local)
              command = c.stop
                state := closeDown
          ALT w=0 FOR SIZE workers
            workers[w] ? command
              IF 
                command = c.message
                  messageHandler(workers[w])
                command = c.patch
                  SEQ
                    patchHandler(workers[w])
                    free.workers[w] := free.workers[w] + 1
                command = c.stop
                  state := closeDown
      out ! c.stop
  :

  -- send map to workers
  PROC sendMap ([]CHAN OF ANY toWorkers)
    SEQ w = 0 FOR SIZE toWorkers
      SEQ
        toWorkers[w] ! c.map
  :

  -- receive mapAck response from all workers
  PROC receiveMapAck ([]CHAN OF ANY fromWorkers)
    INT command:
    [256] INT buffer:
    INT count:
    INT done:
    INT expected:
    BOOL continue:
    SEQ
      done := 0
      expected := SIZE fromWorkers
      continue := TRUE
      WHILE continue
        ALT w=0 FOR SIZE fromWorkers
          fromWorkers[w] ? command
            IF
              command = c.mapAck
                SEQ
                  done := done + 1
                  fromWorkers[w] ? count
                  free.workers[w] := count
                  IF
                    done = expected
                      continue := FALSE
                    TRUE
                      SKIP
  :
 
  --PROC rayTrace ( CHAN OF ANY fromPrev, toPrev, []CHAN OF ANY fromWorkers, []CHAN OF ANY toWorkers,  VAL INT propogate, me )
  CHAN OF ANY toLocal, localDone, fromLocal :
  INT n:
  INT command:
  SEQ
    -- net mapping
    SEQ i=0 FOR SIZE free.workers
      free.workers[i] := 0
    n := SIZE toWorkers
    fromPrev ? command
    IF
      command = c.map
        IF
          propogate <> 0
            SEQ
              sendMap (toWorkers)
              receiveMapAck (fromWorkers)
          TRUE
            SKIP
    n := 1  -- local worker
    SEQ w=0 FOR SIZE free.workers
      SEQ
        n := n + free.workers[w]
    -- send total workers known to this renderer
    toPrev ! c.mapAck; n
    -- normal operation
    WHILE TRUE
      PRI PAR
        PAR
          throughPut  ( fromPrev, toPrev, toWorkers, toLocal, localDone,
                        propogate )
          pixelBypass ( toPrev, fromLocal, fromWorkers )
        renderer   ( toLocal, fromLocal, localDone, me )
:


