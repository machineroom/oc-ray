PROC rayTrace   ( CHAN OF ANY fromPrev, toPrev, fromNext, toNext,
                    VAL INT propogate, me )

  #USE "occama.lib"     --T414 math library
  --#USE "occam8.lib"     --T8xx math library

  #INCLUDE "PROTOCOL.INC"

  #INCLUDE "RENDERER.INC"

  -- accept work from upstream and send it downstream or process locally
  PROC throughPut ( CHAN OF ANY fromPrev, toNext, toLocal, localDone,
                    VAL INT propogate )

    VAL closeDown     IS 0 :
    VAL active        IS 1 :
    VAL busy          IS 2 :

    [256] INT buffer :
    INT state, tag :
    INT x, y, size, kick :
    SEQ
      state := active
      WHILE state <> closeDown
        ALT
          localDone ? kick
            SEQ
              --update local state to indicate free for work
              state := active
          fromPrev ? tag
            IF
              tag = c.render
                INT a, b :
                SEQ
                  fromPrev ? a; b
                  IF
                    state = active
                      SEQ
                        toLocal ! tag; a; b
                        state := busy
                    state = busy
                      SEQ
                        -- pass work onto next
                        toNext ! tag; a; b
              tag = c.stop
                SEQ
                  IF
                    state = busy
                      -- wait for local to finish
                      localDone ? kick
                  toLocal ! tag
                  toNext  ! tag
                  state := closeDown
              TRUE
                SEQ
                  fromPrev ? size; [ buffer FROM 0 FOR size ]
                  IF
                    propogate <> 0
                      toNext ! tag; size; [ buffer FROM 0 FOR size ]
                    TRUE
                      SKIP
                  toLocal ! tag; size; [ buffer FROM 0 FOR size ]
  :


  -- accept input from one of the workers and push the results upstream
  PROC pixelBypass ( CHAN OF ANY out, []CHAN OF ANY workers)
    INT  state, command, x, y, size :
    [256] INT buffer :

    VAL closeDown  IS 0 :
    VAL busy IS 1 :

    SEQ
      state := busy
      WHILE state <> closeDown
        ALT
          ALT w=0 FOR SIZE workers
            workers[w] ? command
              SEQ
                IF
                  command = c.message
                    SEQ
                      workers[w] ? size; [ buffer FROM 0 FOR size ]
                      out ! command; size; [ buffer FROM 0 FOR size ]
                  command = c.patch
                    SEQ
                      workers[w] ? x; y; size
                      out ! command; x; y; size
                      SEQ i = 0 FOR size
                        SEQ
                          workers[w]  ? [ buffer FROM 0 FOR size ]
                          out ! [ buffer FROM 0 FOR size ]

                  command = c.stop
                    --TODO wait for all workers to drain
                    state := closeDown
      out ! c.stop
  :

 
  --PROC rayTrace (CHAN OF ANY fromPrev, toPrev, fromNext, toNext, VAL INT propogate, me)
  CHAN OF ANY toLocal, localDone, fromLocal :

  [2] CHAN OF ANY workers IS [fromNext, fromLocal]:
  
  SEQ
    WHILE TRUE
      PRI PAR
        PAR
          throughPut  ( fromPrev, toNext, toLocal, localDone,
                        propogate )
          pixelBypass ( toPrev, workers )
        renderer   ( toLocal, fromLocal, localDone )
:


