PROC rayTrace   ( CHAN OF ANY fromPrev, toPrev, []CHAN OF ANY fromWorkers, []CHAN OF ANY toWorkers,
                    VAL INT propogate, me )

  #USE "occama.lib"     --T414 math library
  --#USE "occam8.lib"     --T8xx math library

  #INCLUDE "PROTOCOL.INC"

  [256] INT message :
  INT mess.p :
  
  -- max 3 workers (+ local)
  [3]BOOL free.worker:

  PROC wrch ( CHAN OF ANY out, VAL INT ch )
    IF
      ch = (-7)
        SEQ
          out ! c.message; mess.p; [ message FROM 0 FOR mess.p ]
          mess.p := 0
      mess.p = 256
        SKIP
      TRUE
        SEQ
          message [ mess.p] := ch
          mess.p := mess.p + 1
  :


  PROC writen ( CHAN OF ANY out, VAL INT num)
    [20] INT stack :
    INT sp :
    PROC push (VAL INT push)
      SEQ
        stack[sp] := push
        sp := sp + 1
        SKIP
    :

    PROC pop (INT pop)
      SEQ
        sp := sp - 1
        pop := stack[sp]
        SKIP
    :

    VAL nil IS #DEAD :
    INT n :
    SEQ
      IF
        num < 0
          SEQ
            n := -num
            wrch ( out, INT '-')
        TRUE
          n := num
      sp := 0
      push (nil)
      WHILE n > 9
        SEQ
          push (n \ 10)
          n := n / 10
      WHILE n <> nil
        SEQ
          wrch ( out, n + (INT '0'))
          pop (n)
  :

  PROC writef ( CHAN OF ANY out, VAL [] BYTE str, VAL INT a, b, c, d)
    INT chptr, ch, ptr :
    [4] INT args :
    SEQ
      ptr     := 0
      chptr   := 0
      args[0] := a
      args[1] := b
      args[2] := c
      args[3] := d
      WHILE chptr < (SIZE str)
        SEQ
          ch := INT str[chptr]
          IF
            ch = (INT '%')
              SEQ
                chptr := chptr + 1
                ch := INT str [chptr]
                IF
                  (ch = (INT 'I')) OR (ch = (INT 'i'))
                    SEQ
                      writen ( out, args[ptr])
                      IF
                        ptr = 3
                          SKIP
                        TRUE
                          ptr := ptr + 1
                  TRUE
                    SKIP

            TRUE
              wrch ( out, ch)
          chptr := chptr + 1
      wrch ( out, -7)
  :

  #INCLUDE "RENDERER.INC"

  -- accept work from upstream and send it downstream or process locally
  PROC throughPut ( CHAN OF ANY fromPrev, []CHAN OF ANY toWorkers, CHAN OF ANY toLocal, localDone,
                    VAL INT propogate )

    VAL closeDown     IS 0 :
    VAL active        IS 1 :
    VAL busy          IS 2 :

    [256] INT buffer :
    INT state, tag :
    INT x, y, size, kick :
    SEQ
      state := active
      WHILE state <> closeDown
        ALT
          localDone ? kick
            SEQ
              --update local state to indicate free for work
              state := active
          fromPrev ? tag
            IF
              tag = c.render
                INT x, y :
                SEQ
                  fromPrev ? x; y
                  IF
                    state = active
                      SEQ
                        toLocal ! tag; x; y
                        state := busy
                    state = busy
                      SEQ
                        -- pass work onto next free worker
                        SEQ w=0 FOR SIZE toWorkers
                          IF 
                            free.worker[w]
                              SEQ
                                --temp! marking worker as not free will block the rest of the pipe!
                                --free.worker[w] := FALSE
                                toWorkers[w] ! tag; x; y
                            TRUE
                              SKIP
                    TRUE
                      SKIP
              tag = c.stop
                SEQ
                  IF
                    state = busy
                      -- wait for local to finish
                      localDone ? kick
                    TRUE
                      SKIP
                  toLocal ! tag
                  SEQ w=0 FOR SIZE toWorkers
                    toWorkers[w] ! tag
                  state := closeDown
              TRUE
                SEQ
                  fromPrev ? size; [ buffer FROM 0 FOR size ]
                  IF
                    propogate <> 0
                      SEQ w=0 FOR SIZE toWorkers
                        toWorkers[w] ! tag; size; [ buffer FROM 0 FOR size ]
                    TRUE
                      SKIP
                  toLocal ! tag; size; [ buffer FROM 0 FOR size ]
  :


  -- accept results from one of the workers and push the results upstream
  PROC pixelBypass ( CHAN OF ANY out, CHAN OF ANY local, []CHAN OF ANY workers)

    INT  state, command, x, y, size :
    [256] INT buffer :

    VAL closeDown  IS 0 :
    VAL busy IS 1 :

    PROC commandHandler (CHAN OF ANY in)
      SEQ
        IF
          command = c.message
            SEQ
              in ? size; [ buffer FROM 0 FOR size ]
              out ! command; size; [ buffer FROM 0 FOR size ]
          command = c.patch
            SEQ
              in ? x; y; size
              out ! command; x; y; size
              SEQ i = 0 FOR size
                SEQ
                  in  ? [ buffer FROM 0 FOR size ]
                  out ! [ buffer FROM 0 FOR size ]
          command = c.stop
            state := closeDown
    :

    SEQ
      state := busy
      WHILE state <> closeDown
        ALT
          local ? command
            commandHandler(local)
    
          ALT w=0 FOR SIZE workers
            workers[w] ? command
              SEQ
                commandHandler(workers[w])
                free.worker[w] := TRUE
      out ! c.stop
  :

 
  --PROC rayTrace ( CHAN OF ANY fromPrev, toPrev, []CHAN OF ANY fromWorkers, []CHAN OF ANY toWorkers,  VAL INT propogate, me )
  CHAN OF ANY toLocal, localDone, fromLocal :

  SEQ
    PAR i=0 FOR SIZE free.worker
      free.worker[i] := TRUE
    WHILE TRUE
      PRI PAR
        PAR
          throughPut  ( fromPrev, toWorkers, toLocal, localDone,
                        propogate )
          pixelBypass ( toPrev, fromLocal, fromWorkers )
        renderer   ( toLocal, fromLocal, localDone )
:


