PROC rayTrace   ( CHAN OF ANY fromPrev, toPrev, fromNext, toNext,
                    VAL INT propogate, me )

  #USE "occama.lib"     --T414 math library
  --#USE "occam8.lib"     --T8xx math library

  #INCLUDE "PROTOCOL.INC"

  #INCLUDE "RENDERER.INC"

  PROC throughPut ( CHAN OF ANY fromPrev, toNext, toLocal, localDone,
                    VAL INT propogate )

    VAL closeDown     IS 0 :
    VAL active        IS 1 :
    VAL busy          IS 2 :
    VAL buffered      IS 4 :

    [256] INT buffer :
    INT state, tag :
    INT x, y, size, kick :
    SEQ
      state := active
      WHILE state <> closeDown
        PRI ALT
          localDone ? kick  -- should be guarded by (state /\ busy) <> 0 ..
            IF
              (state /\ buffered) <> 0
                SEQ
                  toLocal ! c.render; x; y
                  state := active \/ busy
              TRUE
                state := active -- i.e not busy and not buffered
          fromPrev ? tag
            IF
              tag = c.render
                INT a, b :
                SEQ
                  fromPrev ? a; b
                  IF
                    (state /\ busy) = 0
                      SEQ
                        toLocal ! tag; a; b
                        state := active \/ busy

                    (state /\ buffered) <> 0
                      toNext ! tag; a; b
                    TRUE
                      SEQ
                        x     := a
                        y     := b
                        state := active \/ (busy \/ buffered)
              tag = c.stop
                SEQ
                  IF
                    (state /\ busy) <> 0
                      localDone ? kick
                    TRUE
                      SKIP
                  IF
                    (state /\ buffered) <> 0
                      SEQ
                        toLocal   ! c.render; x; y
                        localDone ? kick
                    TRUE
                      SKIP
                  toLocal ! tag
                  toNext     ! tag
                  state := closeDown
              TRUE
                SEQ
                  fromPrev ? size; [ buffer FROM 0 FOR size ]
                  IF
                    propogate <> 0
                      toNext ! tag; size; [ buffer FROM 0 FOR size ]
                    TRUE
                      SKIP
                  toLocal ! tag; size; [ buffer FROM 0 FOR size ]
  :


  -- accept input from one of the workers and push the results upstream
  PROC pixelBypass ( CHAN OF ANY out, []CHAN OF ANY workers, VAL INT number.of.workers)
    INT  state, command, x, y, size :
    [256] INT buffer :

    VAL closeDown  IS 0 :
    VAL busy IS 1 :

    SEQ
      state := busy
      WHILE state <> closeDown
        ALT
          ALT w=0 FOR number.of.workers
            workers[w] ? command
              SEQ
                IF
                  command = c.message
                    SEQ
                      workers[w] ? size; [ buffer FROM 0 FOR size ]
                      out ! command; size; [ buffer FROM 0 FOR size ]
                  command = c.patch
                    SEQ
                      workers[w] ? x; y; size
                      out ! command; x; y; size
                      --pass ( workers[w], out )
                      SEQ i = 0 FOR size
                        SEQ
                          workers[w]  ? [ buffer FROM 0 FOR size ]
                          out ! [ buffer FROM 0 FOR size ]

                  command = c.stop
                    --TODO wait for all workers to drain
                    state := closeDown
      out ! c.stop
  :

 
  --PROC rayTrace (CHAN OF ANY fromPrev, toPrev, fromNext, toNext, VAL INT propogate, me)
  CHAN OF ANY toLocal, localDone, fromLocal :

  [2] CHAN OF ANY workers IS [fromNext, fromLocal]:
  
  SEQ
    WHILE TRUE
      PRI PAR
        PAR
          throughPut  ( fromPrev, toNext, toLocal, localDone,
                        propogate )
          pixelBypass ( toPrev, workers, SIZE workers )
        renderer   ( toLocal, fromLocal, localDone )
:


