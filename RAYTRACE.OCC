PROC rayTrace   ( CHAN OF ANY fromPrev, toPrev, fromNext, toNext,
                    VAL INT propogate, me )

  #USE "occama.lib"     --T414 math library
  --#USE "occam8.lib"     --T8xx math library

  #INCLUDE "PROTOCOL.INC"

  #INCLUDE "RENDERER.INC"

  PROC throughPut ( [256] INT work,
                    CHAN OF ANY fromPrev, toNext, feedPixels, pixelTrigger,
                    VAL INT propogate )

    VAL closeDown     IS 0 :
    VAL active        IS 1 :
    VAL busy          IS 2 :
    VAL buffered      IS 4 :

    INT state, tag :
    INT x, y, size, kick :
    SEQ
      state := active
      WHILE state <> closeDown
        PRI ALT
          pixelTrigger ? kick  -- should be guarded by (state /\ busy) <> 0 ..
            IF
              (state /\ buffered) <> 0
                SEQ
                  feedPixels ! c.render; x; y
                  state := active \/ busy
              TRUE
                state := active -- i.e not busy and not buffered
          fromPrev ? tag
            IF
              tag = c.render
                INT a, b :
                SEQ
                  fromPrev ? a; b
                  IF
                    (state /\ busy) = 0
                      SEQ
                        feedPixels ! tag; a; b
                        state := active \/ busy

                    (state /\ buffered) <> 0
                      toNext ! tag; a; b
                    TRUE
                      SEQ
                        x     := a
                        y     := b
                        state := active \/ (busy \/ buffered)
              tag = c.stop
                SEQ
                  IF
                    (state /\ busy) <> 0
                      pixelTrigger ? kick
                    TRUE
                      SKIP
                  IF
                    (state /\ buffered) <> 0
                      SEQ
                        feedPixels   ! c.render; x; y
                        pixelTrigger ? kick
                    TRUE
                      SKIP
                  feedPixels ! tag
                  toNext     ! tag
                  state := closeDown
              TRUE
                SEQ
                  fromPrev ? size; [ work FROM 0 FOR size ]
                  IF
                    propogate <> 0
                      toNext ! tag; size; [ work FROM 0 FOR size ]
                    TRUE
                      SKIP
                  feedPixels ! tag; size; [ work FROM 0 FOR size ]
  :


  -- accept input from one of the workers and push the results upstream
  PROC pixelBypass ( CHAN OF ANY out, []CHAN OF ANY workers, VAL INT number.of.workers)
    INT  state, command, x, y, size :
    [256] INT buffer :

    VAL closeDown  IS 0 :
    VAL lubThis    IS 1 :
    VAL lubOther   IS 2 :

    PROC pass ( CHAN OF ANY in, out )
      SEQ i = 0 FOR size
        SEQ
          in  ? [ buffer FROM 0 FOR size ]
          out ! [ buffer FROM 0 FOR size ]
    :
    
    SEQ
      state := lubThis \/ lubOther
      WHILE state <> closeDown
        ALT
          ALT i=0 FOR number.of.workers
            workers[i] ? command
              SEQ
                IF
                  command = c.message
                    SEQ
                      workers[i] ? size; [ buffer FROM 0 FOR size ]
                      out ! command; size; [ buffer FROM 0 FOR size ]
                  command = c.patch
                    SEQ
                      workers[i] ? x; y; size
                      out ! command; x; y; size
                      pass ( workers[i], out )
                  command = c.stop
                    state := state >< lubOther -- >< bitwise xor
      out ! c.stop
  :

 
  --PROC rayTrace (CHAN OF ANY fromPrev, toPrev, fromNext, toNext, VAL INT propogate, me)
  CHAN OF ANY feedPixels, pixelTrigger, pixelsOut :

  [4][256] INT buffers :
  [2] CHAN OF ANY workers IS [fromNext, pixelsOut]:
  
  SEQ
    --workers[0] := fromNext
    --workers[1] := pixelsOut

    WHILE TRUE
      PRI PAR
        PAR
          throughPut  ( buffers [0],
                        fromPrev, toNext, feedPixels, pixelTrigger,
                        propogate )
          pixelBypass ( toPrev, workers, 2 )
        renderer   ( feedPixels, pixelsOut, pixelTrigger )
:


